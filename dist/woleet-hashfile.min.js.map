{"version":3,"sources":["woleet-hashfile.js"],"names":["root","factory","woleet","window","findBasePath","scripts","document","getElementsByTagName","scriptsArray","Array","prototype","slice","call","script","src","match","regex","substr","lastIndexOf","checkFileReaderSyncSupport","makeWorker","URL","webkitURL","Blob","Worker","blob","createObjectURL","Promise","syncDetectionScript","resolve","worker","onmessage","e","terminate","data","err","api","file","protocol","testNativeCryptoSupport","crypto","subtle","digest","isHTTPS","basePath","DEFAULT_WORKER_SCRIPT","workerScriptPath","Hasher","ready","cb_start","cb_progress","cb_result","cb_error","cancel","onCancel","cb","this","event","callback","HashWorker","hash","next","reject","message","progress","result","start","undefined","console","postMessage","hashLocal","error","Error","size","cancelled","reader","FileReader","abort","algo","SHA256","create","prev","onloadstart","sha256","onloadend","finalize","_hash","toString","CryptoJS","enc","Hex","onprogress","buf","loaded","chunkUint8","Uint8Array","target","WordArray","update","wordArr","total","onabort","hashLocalWithNativeAPI","alg","onload","reduce","res","hexString","catch","hashResult","readAsArrayBuffer","files","max_native_crypto_size","hashWorker","FileList","File","testFileReaderSupport","WorkerSupported","iter","i","len","hashMethod","_worker","length","isReady","hashFileOrCheckHash","progressCallback","hasher","on","isSHA256"],"mappings":"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","file":"woleet-hashfile.min.js","sourcesContent":["/**\n * @typedef {Object}   ProgressMessage\n * @typedef {Number}   ProgressMessage.progress (float number)\n * @typedef {File}     ProgressMessage.file\n */\n\n/**\n * @typedef {Object}   StartMessage\n * @typedef {Boolean}  StartMessage.start always true\n * @typedef {File}     ProgressMessage.file\n */\n\n/**\n * @typedef {Object}   ErrorMessage\n * @typedef {Error}    ErrorMessage.error\n * @typedef {File}     EndMessage.file\n */\n\n/**\n * @typedef {Object}   EndMessage\n * @typedef {String}   EndMessage.end hash of the file\n * @typedef {File}     EndMessage.file\n */\n\n;(function (root, factory) {\n    root.woleet = factory(root.woleet)\n})(window, function (woleet) {\n\n    const api = woleet || {};\n    api.file = api.file || {};\n\n    const isHTTPS = location.protocol == 'https:';\n\n    //noinspection JSUnresolvedVariable\n    const testNativeCryptoSupport = window.crypto && window.crypto.subtle && window.crypto.subtle.digest && isHTTPS;\n\n    const testFileReaderSupport = checkFileReaderSyncSupport();\n\n    /**\n     * @returns {String} get the base path (including final '/') of the current script.\n     */\n    function findBasePath() {\n        let scripts = document.getElementsByTagName('script');\n        let scriptsArray = Array.prototype.slice.call(scripts, 0); // Converts collection to array\n        let regex = /.*woleet-(hashfile|weblibs)[.min]*\\.js$/;\n        let script = scriptsArray.find((script) => script.src && script.src.match(regex));\n        return script && script.src ? script.src.substr(0, script.src.lastIndexOf(\"/\") + 1) : null;\n    }\n\n    // Guess the path of the worker script: same as current script's or defined by woleet.workerScriptPath\n    let basePath = findBasePath();\n    let DEFAULT_WORKER_SCRIPT = \"woleet-hashfile-worker.min.js\";\n    //noinspection JSUnresolvedVariable\n    let workerScriptPath = (api.workerScriptPath || (basePath ? basePath + DEFAULT_WORKER_SCRIPT : null));\n    if (!workerScriptPath)\n        throw new Error('Cannot find ' + DEFAULT_WORKER_SCRIPT);\n\n    /**\n     * Check support for workers.\n     */\n    function checkFileReaderSyncSupport() {\n\n        function makeWorker(script) {\n            //noinspection JSUnresolvedVariable\n            let URL = window.URL || window.webkitURL;\n            let Blob = window.Blob;\n            let Worker = window.Worker;\n\n            if (!URL || !Blob || !Worker || !script) return null;\n\n            let blob = new Blob([script]);\n            //noinspection JSUnresolvedFunction\n            return new Worker(URL.createObjectURL(blob));\n        }\n\n        return new Promise(function (resolve) {\n            let syncDetectionScript = \"onmessage = function(e) { postMessage(!!FileReaderSync); close() };\";\n            try {\n                let worker = makeWorker(syncDetectionScript);\n                if (worker) {\n                    worker.onmessage = function (e) {\n                        worker.terminate();\n                        worker = null;\n                        resolve(e.data);\n                    };\n                    worker.postMessage({});\n                }\n                else resolve(false);\n            } catch (err) {\n                resolve(false);\n            }\n        });\n    }\n\n    api.file.Hasher = function () {\n\n        let ready = true;\n        let cb_start, cb_progress, cb_result, cb_error;\n        let cancel = null;\n        const onCancel = (cb) => cancel = cb;\n\n        /**\n         * @param {String} event\n         * @param {Function} callback\n         */\n        this.on = function (event, callback) {\n            switch (event) {\n                case 'start':\n                    cb_start = callback;\n                    break;\n                case 'progress':\n                    cb_progress = callback;\n                    break;\n                case 'error':\n                    cb_error = callback;\n                    break;\n                case 'result':\n                    cb_result = callback;\n                    break;\n                default:\n                    throw new Error('Invalid event name \"' + event + '\"');\n            }\n        };\n\n        /**\n         * @constructor\n         */\n        const HashWorker = function () {\n\n            let worker = new Worker(workerScriptPath);\n\n            /**\n             * @param {File} file\n             * @returns {Promise}\n             */\n            this.hash = function (file) {\n\n                return new Promise((next, reject) => {\n\n                    onCancel(() => {\n                        worker.terminate();\n                        worker = null;\n                        reject('cancelled')\n                    });\n\n                    worker.onmessage = function (message) {//handling worker message\n                        if (message.data.progress != undefined) {\n                            if (cb_progress) cb_progress(message.data);\n                        }\n                        else if (message.data.result) {\n                            if (cb_result) cb_result(message.data);\n                            next(worker);\n                        }\n                        else if (message.data.start) {\n                            if (cb_start) cb_start(message.data);\n                        }\n                        else if (message.data.error) {\n                            let error = message.data.error;\n                            if (cb_error) cb_error(error);\n                            else reject(error);\n                        }\n                        else {\n                            console.trace(\"Unexpected worker message: \", message);\n                        }\n                    };\n\n                    worker.postMessage(file);\n                });\n            };\n\n        };\n\n        /**\n         * @param {File} file\n         * @returns {Promise}\n         */\n        const hashLocal = function (file) {\n            return new Promise((next, reject) => {\n                let error = new Error(\"file_too_big_to_be_hashed_without_worker\");\n                if (file.size > 5e7) {\n                    ready = true;\n                    if (cb_error) return cb_error({error: error, file: file});\n                    else reject(error);\n                }\n\n                let cancelled = false;\n                const reader = new FileReader();\n\n                onCancel(() => {\n                    cancelled = true;\n                    reader.abort()\n                });\n\n                let sha256 = CryptoJS.algo.SHA256.create();\n                let hash, prev = 0;\n                reader.onloadstart = () => {\n                    if (cancelled) return;\n                    if (cb_start) cb_start({start: true, file: file});\n                };\n\n                reader.onloadend = () => {\n                    if (cancelled) return;\n\n                    hash.finalize();\n                    if (cb_result) cb_result({\n                        result: hash._hash.toString(CryptoJS.enc.Hex),\n                        file: file\n                    });\n                    next();\n                };\n\n                reader.onprogress = (e) => {\n                    if (cancelled) return;\n\n                    /** @type ArrayBuffer */\n                    let buf = e.target.result;\n                    //noinspection JSUnresolvedVariable\n                    let blob = buf.slice(prev, e.loaded);\n                    let chunkUint8 = new Uint8Array(blob);\n                    let wordArr = CryptoJS.lib.WordArray.create(chunkUint8);\n                    hash = sha256.update(wordArr);\n                    //noinspection JSUnresolvedVariable\n                    prev = e.loaded;\n                    if (cb_progress) {\n                        //noinspection JSUnresolvedVariable\n                        cb_progress({progress: (e.loaded / e.total), file: file});\n                    }\n                };\n\n                reader.onabort = () => {\n                    reject('cancelled')\n                };\n\n                reader.readAsArrayBuffer(file);\n            });\n        };\n\n        /**\n         * @param {File} file\n         * @returns {Promise}\n         */\n        const hashLocalWithNativeAPI = function (file) {\n            return new Promise((resolve, reject) => {\n                const alg = \"SHA-256\";\n                let cancelled = false;\n                // entry point\n                const reader = new FileReader();\n\n                onCancel(() => {\n                    cancelled = true;\n                    reader.abort()\n                });\n\n                reader.onloadstart = () => {\n                    if (cancelled) return;\n                    if (cb_start) cb_start({start: true, file: file});\n                };\n\n                reader.onprogress = (e) => {\n                    if (cancelled) return;\n                    if (cb_progress) { //noinspection JSUnresolvedVariable\n                        cb_progress({progress: (e.loaded / e.total), file: file});\n                    }\n                };\n\n                reader.onload = function (event) {\n                    if (cancelled) return;\n                    let data = event.target.result;\n                    //noinspection JSUnresolvedFunction,JSUnresolvedVariable\n                    window.crypto.subtle.digest(alg, data)\n                        .then(function (hash) {\n                            let hashResult = new Uint8Array(hash);\n                            let hexString = hashResult.reduce((res, e) => res + ('00' + e.toString(16)).slice(-2), '');\n                            if (cb_result) cb_result({result: hexString, file: file});\n                            resolve();\n                        })\n                        .catch((error) => cb_error ? cb_error({error: error, file: file}) : reject(error));\n                };\n\n                reader.onabort = () => {\n                    reject('cancelled')\n                };\n\n                reader.readAsArrayBuffer(file);\n            })\n        };\n\n        this.start = function (files) {\n\n            const max_native_crypto_size = 5e8; // ~500MB\n\n            let hashWorker = null; // We may have to keep the hashWorker\n\n            if (!ready) throw new Error(\"not_ready\");\n\n            ready = false;\n\n            // checking input type\n            if (!(files instanceof FileList || files instanceof File))\n                throw new Error(\"invalid_parameter\");\n\n            testFileReaderSupport\n                .then((WorkerSupported) => {\n\n                    /**\n                     * iterator function with selected hash method\n                     * @param {Number} i current index of the list\n                     * @param {Number} len total size of the list\n                     * @param {FileList|[File]} files file list\n                     * @param {Worker} [worker] passing worker through iterator if selected method is hashWorker in order to terminate it\n                     */\n                    function iter(i, len, files, worker) {\n\n                        if ((i >= len)) {\n                            ready = true;\n                            if (worker) {\n                                worker.terminate();\n                                worker = null;\n                            }\n                        }\n                        else {\n\n                            // We choose here the better method to hash a file\n                            let hashMethod = null;\n                            if (testNativeCryptoSupport && files[i].size < max_native_crypto_size) {\n                                hashMethod = hashLocalWithNativeAPI;\n                            }\n                            else if (WorkerSupported) {\n                                if (!hashWorker) hashWorker = new HashWorker(); // if worker instance has already been called\n                                hashMethod = hashWorker.hash;\n                            }\n                            else if (typeof CryptoJS !== 'undefined') {\n                                hashMethod = hashLocal;\n                            }\n                            else {\n                                ready = true;\n                                throw new Error(\"no_viable_hash_method\");\n                            }\n\n                            return hashMethod(files[i])\n                                .then((_worker) => iter(i + 1, len, files, _worker || worker))\n                                .catch((err) => {\n                                    if (err !== 'cancelled') throw err;\n                                })\n                        }\n                    }\n\n                    // entry point\n                    if (files instanceof FileList) { // files is a FileList\n                        return iter(0, files.length, files);\n                    }\n                    else if (files instanceof File) { // files is a single file\n                        return iter(0, 1, [files]);\n                    }\n                })\n\n        };\n\n        this.cancel = function () {\n            if (cancel) {\n                cancel();\n                cancel = null;\n                ready = true;\n            }\n        };\n\n        this.isReady = () => ready;\n    };\n\n    /**\n     * @param {File|String} file\n     * @param {Function} [progressCallback]\n     * @returns {Promise<Hash>}\n     */\n    api.hashFileOrCheckHash = (file, progressCallback) => {\n        return new Promise((resolve, reject) => {\n\n            // If parameter is a file, hash it\n            if (file instanceof File) {\n\n                if (!api.file || !api.file.Hasher)\n                    throw new Error(\"missing_woleet_hash_dependency\");\n\n                const hasher = new api.file.Hasher;\n\n                hasher.on('result', (message, file) => {\n                    resolve(message.result);\n                    if (progressCallback)\n                        progressCallback({progress: 1.0, file: file})\n                });\n\n                if (progressCallback && typeof progressCallback == 'function')\n                    hasher.on('progress', progressCallback);\n\n                hasher.on('error', reject);\n\n                hasher.start(file)\n            }\n\n            // If parameter is a hash, check it is a valid SHA256 hash\n            else if (typeof file == \"string\") {\n                if (api.isSHA256(file))\n                    resolve(file);\n                else\n                    reject(new Error(\"parameter_string_not_a_sha256_hash\"));\n            }\n\n            // Invalid parameter\n            else\n                reject(new Error(\"invalid_parameter\"));\n        });\n    };\n\n    return api;\n});"]}