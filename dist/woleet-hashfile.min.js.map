{"version":3,"sources":["woleet-hashfile.js"],"names":["root","factory","woleet","window","findBasePath","scripts","document","getElementsByTagName","scriptsArray","Array","prototype","slice","call","script","src","match","regex","substr","lastIndexOf","checkFileReaderSyncSupport","makeWorker","URL","webkitURL","Blob","Worker","blob","createObjectURL","Promise","syncDetectionScript","resolve","worker","onmessage","e","testFileReaderSupport","crypto","subtle","digest","testNativeCryptoSupport","api","file","basePath","DEFAULT_WORKER_SCRIPT","workerScriptPath","Hasher","ready","cb_start","cb_progress","cb_result","cb_error","this","on","event","callback","Error","HashWorker","hash","next","reject","message","undefined","data","progress","result","error","start","console","trace","postMessage","hashLocal","size","reader","FileReader","algo","SHA256","create","prev","onloadstart","onloadend","finalize","_hash","toString","CryptoJS","enc","Hex","onprogress","buf","target","loaded","chunkUint8","Uint8Array","wordArr","lib","WordArray","sha256","update","total","readAsArrayBuffer","hashLocalWithNativeAPI","onload","hashResult","hexString","reduce","res","files","FileList","File","then","WorkerSupported","i","len","hashMethod","iter","hashWorker","length","isReady","_hashStringOrFile","progressCallback","resolveHash","rejectHash","hashPromise","hasher","isSHA256"],"mappings":"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","file":"woleet-hashfile.min.js","sourcesContent":["/**\n * @typedef {Object}   ProgressMessage\n * @typedef {Number}   ProgressMessage.progress (float number)\n * @typedef {File}     ProgressMessage.file\n */\n\n/**\n * @typedef {Object}   StartMessage\n * @typedef {Boolean}  StartMessage.start always true\n * @typedef {File}     ProgressMessage.file\n */\n\n/**\n * @typedef {Object}   ErrorMessage\n * @typedef {Error}    ErrorMessage.error\n * @typedef {File}     EndMessage.file\n */\n\n/**\n * @typedef {Object}   EndMessage\n * @typedef {String}   EndMessage.end hash of the file\n * @typedef {File}     EndMessage.file\n */\n\n;(function (root, factory) {\n    root.woleet = factory(root.woleet)\n})(window, function (woleet) {\n\n    const testFileReaderSupport = checkFileReaderSyncSupport();\n    //noinspection JSUnresolvedVariable\n    const testNativeCryptoSupport = window.crypto && window.crypto.subtle && window.crypto.subtle.digest;\n\n    const api = woleet || {};\n    api.file = api.file || {};\n\n    /**\n     * @returns {String} get the base path (including final '/') of the current script.\n     */\n    function findBasePath() {\n        let scripts = document.getElementsByTagName('script');\n        let scriptsArray = Array.prototype.slice.call(scripts, 0); // Converts collection to array\n        let regex = /.*woleet-(hashfile|weblibs)[.min]*\\.js$/;\n        let script = scriptsArray.find((script) => script.src && script.src.match(regex));\n        return script && script.src ? script.src.substr(0, script.src.lastIndexOf(\"/\") + 1) : null;\n    }\n\n    // Guess the path of the worker script: same as current script's or defined by woleet.workerScriptPath\n    let basePath = findBasePath();\n    let DEFAULT_WORKER_SCRIPT = \"woleet-hashfile-worker.min.js\";\n    //noinspection JSUnresolvedVariable\n    let workerScriptPath = (api.workerScriptPath || (basePath ? basePath + DEFAULT_WORKER_SCRIPT : null));\n    if (!workerScriptPath)\n        throw new Error('Cannot find ' + DEFAULT_WORKER_SCRIPT);\n\n    /**\n     * Check support for workers.\n     */\n    function checkFileReaderSyncSupport() {\n\n        function makeWorker(script) {\n            //noinspection JSUnresolvedVariable\n            let URL = window.URL || window.webkitURL;\n            let Blob = window.Blob;\n            let Worker = window.Worker;\n\n            if (!URL || !Blob || !Worker || !script) return null;\n\n            let blob = new Blob([script]);\n            //noinspection JSUnresolvedFunction\n            return new Worker(URL.createObjectURL(blob));\n        }\n\n        return new Promise(function (resolve) {\n            let syncDetectionScript = \"onmessage = function(e) { postMessage(!!FileReaderSync); };\";\n            try {\n                let worker = makeWorker(syncDetectionScript);\n                if (worker) {\n                    worker.onmessage = function (e) {\n                        resolve(e.data);\n                    };\n                    worker.postMessage({});\n                }\n                else resolve(false);\n            } catch (err) {\n                resolve(false);\n            }\n        });\n    }\n\n    api.file.Hasher = function () {\n\n        let ready = true;\n        let cb_start, cb_progress, cb_result, cb_error;\n\n        /**\n         * @param {String} event\n         * @param {Function} callback\n         */\n        this.on = function (event, callback) {\n            switch (event) {\n                case 'start':\n                    cb_start = callback;\n                    break;\n                case 'progress':\n                    cb_progress = callback;\n                    break;\n                case 'error':\n                    cb_error = callback;\n                    break;\n                case 'result':\n                    cb_result = callback;\n                    break;\n                default:\n                    throw new Error('Invalid event name \"' + event + '\"');\n            }\n        };\n\n        /**\n         * @constructor\n         */\n        const HashWorker = function () {\n\n            let worker = new Worker(workerScriptPath);\n\n            /**\n             * @param {File} file\n             * @returns {Promise}\n             */\n            this.hash = function (file) {\n                return new Promise((next, reject) => {\n\n                    worker.onmessage = function (message) {//handling worker message\n                        if (message.data.progress != undefined) {\n                            if (cb_progress) cb_progress(message.data);\n                        }\n                        else if (message.data.result) {\n                            if (cb_result) cb_result(message.data);\n                            next(worker);\n                        }\n                        else if (message.data.start) {\n                            if (cb_start) cb_start(message.data);\n                        }\n                        else if (message.data.error) {\n                            let error = message.data.error;\n                            if (cb_error) cb_error(error);\n                            else reject(error);\n                        }\n                        else {\n                            console.trace(\"Unexpected worker message: \", message);\n                        }\n                    };\n\n                    worker.postMessage(file);\n                });\n            };\n\n        };\n\n        /**\n         * @param {File} file\n         * @returns {Promise}\n         */\n        const hashLocal = function (file) {\n\n            return new Promise((next, reject) => {\n                let error = new Error(\"file_too_big_to_be_hashed_without_worker\");\n                if (file.size > 5e7) {\n                    ready = true;\n                    if (cb_error) return cb_error({error: error, file: file});\n                    else reject(error);\n                }\n\n                let reader = new FileReader();\n\n                let sha256 = CryptoJS.algo.SHA256.create();\n                let hash, prev = 0;\n\n                reader.onloadstart = () => {\n                    if (cb_start) cb_start({start: true, file: file});\n                };\n\n                reader.onloadend = () => {\n                    hash.finalize();\n                    if (cb_result) cb_result({\n                        result: hash._hash.toString(CryptoJS.enc.Hex),\n                        file: file\n                    });\n                    next();\n                };\n\n                reader.onprogress = (e) => {\n                    //noinspection JSUnresolvedVariable\n                    /** @type ArrayBuffer */\n                    let buf = e.target.result;\n                    //noinspection JSUnresolvedVariable\n                    let blob = buf.slice(prev, e.loaded);\n                    let chunkUint8 = new Uint8Array(blob);\n                    let wordArr = CryptoJS.lib.WordArray.create(chunkUint8);\n                    hash = sha256.update(wordArr);\n                    //noinspection JSUnresolvedVariable\n                    prev = e.loaded;\n                    if (cb_progress) {\n                        //noinspection JSUnresolvedVariable\n                        cb_progress({progress: (e.loaded / e.total), file: file});\n                    }\n                };\n\n                reader.readAsArrayBuffer(file);\n            });\n        };\n\n        /**\n         * @param {File} file\n         * @returns {Promise}\n         */\n        const hashLocalWithNativeAPI = function (file) {\n            return new Promise((resolve, reject) => {\n                let algo = \"SHA-256\";\n                // entry point\n                let reader = new FileReader();\n\n                reader.onloadstart = () => {\n                    if (cb_start) cb_start({start: true, file: file});\n                };\n\n                reader.onprogress = (e) => {\n                    if (cb_progress) { //noinspection JSUnresolvedVariable\n                        cb_progress({progress: (e.loaded / e.total), file: file});\n                    }\n                };\n\n                reader.onload = function (event) {\n                    let data = event.target.result;\n                    //noinspection JSUnresolvedFunction,JSUnresolvedVariable\n                    window.crypto.subtle.digest(algo, data)\n                        .then(function (hash) {\n                            let hashResult = new Uint8Array(hash);\n                            let hexString = hashResult.reduce((res, e) => res + ('00' + e.toString(16)).slice(-2), '');\n                            if (cb_result) cb_result({result: hexString, file: file});\n                            resolve();\n                        })\n                        .catch((error) => cb_error ? cb_error({error: error, file: file}) : reject(error));\n                };\n\n                reader.readAsArrayBuffer(file);\n            })\n        };\n\n        this.start = function (files) {\n\n            if (!ready) throw new Error(\"not_ready\");\n\n            ready = false;\n\n            // checking input type\n            if (!(files instanceof FileList || files instanceof File))\n                throw new Error(\"invalid_parameter\");\n\n            testFileReaderSupport\n                .then((WorkerSupported) => {\n                    let hashMethod = null;\n                    if (testNativeCryptoSupport) {\n                        hashMethod = hashLocalWithNativeAPI;\n                    }\n                    else if (WorkerSupported) {\n                        let hashWorker = new HashWorker();\n                        hashMethod = hashWorker.hash;\n                    }\n                    else if (typeof CryptoJS !== 'undefined') {\n                        hashMethod = hashLocal;\n                    }\n                    else {\n                        throw new Error(\"no_viable_hash_method\");\n                    }\n\n                    /**\n                     * iterator function with selected hash method\n                     * @param i current index of the list\n                     * @param len total size of the list\n                     * @param worker passing worker through iterator if selected method is hashWorker in order to terminate it\n                     */\n                    function iter(i, len, worker) {\n                        if ((i >= len)) {\n                            ready = true;\n                            if (worker) worker.terminate();\n                        }\n                        else {\n                            hashMethod(files[i]).then((worker) => {\n                                iter(++i, len, worker);\n                            })\n                        }\n                    }\n\n                    // entry point\n                    if (files instanceof FileList) { // files is a FileList\n                        iter(0, files.length);\n                    }\n                    else if (files instanceof File) { // files is a single file\n                        hashMethod(files).then((worker) => {\n                            iter(1, 0, worker); // set ready state with iter function (i > len)\n                        })\n                    }\n                })\n\n        };\n\n        this.isReady = function () {\n            return ready;\n        };\n    };\n\n    /**\n     * @param {File|String} file\n     * @param {Function} [progressCallback]\n     * @returns {Promise<Hash>}\n     */\n    api._hashStringOrFile = function (file, progressCallback) {\n        let resolveHash;\n        let rejectHash;\n        let hashPromise = new Promise(function (resolve, reject) {\n            resolveHash = resolve;\n            rejectHash = reject;\n        });\n\n        if (file instanceof File) {\n\n            if (!api.file || !api.file.Hasher) throw new Error(\"missing_woleet_hash_dependency\");\n\n            let hasher = new api.file.Hasher;\n            //noinspection JSUnusedLocalSymbols\n            hasher.on('result', function (message, file) {\n                resolveHash(message.result);\n                if (progressCallback) progressCallback({progress: 1.0, file: File})\n            });\n\n            if (progressCallback && typeof progressCallback == 'function') {\n                hasher.on('progress', progressCallback);\n            }\n\n            hasher.on('error', function (error) {\n                rejectHash(error);\n            });\n\n            hasher.start(file)\n        }\n        else if (typeof file == \"string\") {\n            if (api.isSHA256(file)) {\n                //noinspection JSUnusedAssignment\n                resolveHash(file);\n            }\n            else {\n                //noinspection JSUnusedAssignment\n                rejectHash(new Error(\"parameter_string_not_a_sha256_hash\"));\n            }\n        }\n        else {\n            //noinspection JSUnusedAssignment\n            rejectHash(new Error(\"invalid_parameter\"));\n        }\n\n        return hashPromise;\n    };\n\n    return api;\n});"]}