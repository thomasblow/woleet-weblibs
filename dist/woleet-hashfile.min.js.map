{"version":3,"sources":["woleet-hashfile.js"],"names":["root","factory","woleet","window","findBasePath","scripts","document","getElementsByTagName","script","length","src","checkFileReaderSyncSupport","URL","makeWorker","webkitURL","Blob","Worker","blob","Promise","resolve","syncDetectionScript","worker","e","data","postMessage","err","api","file","basePath","DEFAUlT_WORKER_SCRIPT","workerScriptPath","testFileReaderSupport","Hasher","ready","cb_progress","cb_result","cb_error","this","on","event","callback","cb_start","Error","hashWorker","files","len","i","item","onmessage","message","progress","result","next","error","console","trace","hashLocal","hash","reader","FileReader","start","finalize","algo","SHA256","create","_hash","toString","CryptoJS","enc","Hex","onprogress","wordArr","buf","slice","prev","loaded","Uint8Array","lib","WordArray","chunkUint8","sha256","update","readAsArrayBuffer","total","FileList","then","supported","isReady"],"mappings":"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","file":"woleet-hashfile.min.js","sourcesContent":["/**\n * @typedef {Object}   ProgressMessage\n * @typedef {Number}   ProgressMessage.progress (float number)\n * @typedef {File}     ProgressMessage.file\n */\n\n/**\n * @typedef {Object}   StartMessage\n * @typedef {Boolean}  StartMessage.start always true\n * @typedef {File}     ProgressMessage.file\n */\n\n/**\n * @typedef {Object}   ErrorMessage\n * @typedef {Error}    ErrorMessage.error\n * @typedef {File}     EndMessage.file\n */\n\n/**\n * @typedef {Object}   EndMessage\n * @typedef {String}   EndMessage.end hash of the file\n * @typedef {File}     EndMessage.file\n */\n\n;(function (root, factory) {\n    root.woleet = factory(root.woleet)\n})(window, function (woleet) {\n\n    var api = woleet || {};\n    api.file = api.file || {};\n\n    /**\n     * @returns the base path (including final '/') of the current script.\n     */\n    function findBasePath() {\n        var scripts = document.getElementsByTagName('script'),\n            script = scripts[scripts.length - 1].src, // last script is always the current script\n            basePath = script.substr(0, script.lastIndexOf(\"/\") + 1);\n        return basePath;\n    }\n\n    // Guess the path of the worker script: same as current script's or defined by woleet.workerScriptPath\n    var basePath = findBasePath();\n    var DEFAUlT_WORKER_SCRIPT = \"woleet-hashfile-worker.min.js\";\n    var workerScriptPath = (api.workerScriptPath || (basePath ? basePath + DEFAUlT_WORKER_SCRIPT : null));\n    if (!workerScriptPath)\n        throw new Error('Cannot find ' + DEFAUlT_WORKER_SCRIPT);\n\n    /**\n     * Check support for workers.\n     */\n    function checkFileReaderSyncSupport() {\n\n        function makeWorker(script) {\n            //noinspection JSUnresolvedVariable\n            var URL = window.URL || window.webkitURL;\n            var Blob = window.Blob;\n            var Worker = window.Worker;\n\n            if (!URL || !Blob || !Worker || !script) return null;\n\n            var blob = new Blob([script]);\n            //noinspection JSUnresolvedFunction\n            return new Worker(URL.createObjectURL(blob));\n        }\n\n        return new Promise(function (resolve) {\n            var syncDetectionScript = \"onmessage = function(e) { postMessage(!!FileReaderSync); };\";\n            try {\n                var worker = makeWorker(syncDetectionScript);\n                if (worker) {\n                    worker.onmessage = function (e) {\n                        resolve(e.data);\n                    };\n                    worker.postMessage({});\n                }\n                else resolve(false);\n            } catch (err) {\n                resolve(false);\n            }\n        });\n    }\n\n    var testFileReaderSupport = checkFileReaderSyncSupport();\n\n    api.file.Hasher = function () {\n\n        var ready = true;\n        var cb_start, cb_progress, cb_result, cb_error;\n\n        /**\n         * @param {String} event\n         * @param {Function} callback\n         */\n        this.on = function (event, callback) {\n            switch (event) {\n                case 'start':\n                    cb_start = callback;\n                    break;\n                case 'progress':\n                    cb_progress = callback;\n                    break;\n                case 'error':\n                    cb_error = callback;\n                    break;\n                case 'result':\n                    cb_result = callback;\n                    break;\n                default:\n                    throw new Error('Invalid event name \"' + event + '\"');\n            }\n        };\n\n        /**\n         * @param {FileList|File} files\n         * @param {Number} len\n         */\n        var hashWorker = function (files, len) {\n            var i = 0;\n            var worker = new Worker(workerScriptPath);\n\n            worker.onmessage = function (message) {//handling worker message\n                if (message.data.progress != undefined) {\n                    if (cb_progress) cb_progress(message.data);\n                }\n                else if (message.data.result) {\n                    if (cb_result) cb_result(message.data);\n                    next();\n                }\n                else if (message.data.start) {\n                    if (cb_start) cb_start(message.data);\n                }\n                else if (message.data.error) {\n                    var error = message.data.error;\n                    if (cb_error) cb_error(error);\n                    else throw error;\n                }\n                else {\n                    console.trace(\"Unexpected worker message: \", message);\n                }\n            };\n\n            function next() {\n                if ((i >= len)) {\n                    worker.terminate();\n                    ready = true;\n                }\n                else {\n                    worker.postMessage(files.item(i));\n                    i++;\n                }\n            }\n\n            //entry point\n            if (len != -1) next();// if files is a list\n            else {\n                worker.postMessage(files);\n            }\n        };\n\n        /**\n         * @param {FileList|File} files\n         * @param {Number} len\n         */\n        var hashLocal = function (files, len) {\n            var i = 0;\n\n            /**\n             * @param {File} file\n             */\n            function hash(file) {\n                var err = new Error(\"file_too_big_to_be_hashed_without_worker\");\n                if (file.size > 5e7) {\n                    ready = true;\n                    if (cb_error) return cb_error({error: err, file: file});\n                    else throw err;\n                }\n                if (cb_start) cb_start({start: true, file: file});\n\n                var reader = new FileReader();\n\n                var sha256 = CryptoJS.algo.SHA256.create();\n                var hash, prev = 0;\n\n                reader.onloadend = function () {\n                    hash.finalize();\n                    if (cb_result) cb_result({\n                        result: hash._hash.toString(CryptoJS.enc.Hex),\n                        file: file\n                    });\n                    next();\n                };\n\n                reader.onprogress = function (e) {\n                    //noinspection JSUnresolvedVariable\n                    /** @type ArrayBuffer */\n                    var buf = e.target.result;\n                    //noinspection JSUnresolvedVariable\n                    var blob = buf.slice(prev, e.loaded);\n                    var chunkUint8 = new Uint8Array(blob);\n                    var wordArr = CryptoJS.lib.WordArray.create(chunkUint8);\n                    hash = sha256.update(wordArr);\n                    //noinspection JSUnresolvedVariable\n                    prev = e.loaded;\n                    if (cb_progress) {\n                        //noinspection JSUnresolvedVariable\n                        cb_progress({progress: (e.loaded / e.total), file: file});\n                    }\n                };\n\n                reader.readAsArrayBuffer(file);\n            }\n\n            function next() {\n                if ((i >= len)) {\n                    ready = true;\n                }\n                else {\n                    hash(files.item(i));\n                    i++;\n                }\n            }\n\n            //entry point\n            if (len != -1) next();// if files is a list\n            else {\n                hash(files);\n            }\n        };\n\n        this.start = function (files) {\n\n            if (!ready) throw new Error(\"not_ready\");\n\n            var len = -1;\n\n            if (files instanceof FileList) {\n                len = files.length;\n            }\n            else if (files instanceof File) {\n\n            }\n            else throw new Error(\"invalid_parameter\");\n\n            ready = false;\n\n            testFileReaderSupport.then(function (supported) {\n                if (supported) {\n                    hashWorker(files, len);\n                }\n                else if (typeof CryptoJS !== 'undefined') {\n                    hashLocal(files, len);\n                }\n                else {\n                    throw new Error(\"no_viable_hash_method\");\n                }\n            });\n\n        };\n\n        this.isReady = function () {\n            return ready;\n        };\n    };\n\n    return api;\n});"]}