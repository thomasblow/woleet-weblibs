{"version":3,"sources":["woleet-hashfile.js"],"names":["root","factory","woleet","window","findBasePath","scripts","document","getElementsByTagName","script","length","src","checkFileReaderSyncSupport","makeWorker","URL","webkitURL","Blob","Worker","blob","createObjectURL","Promise","resolve","syncDetectionScript","worker","onmessage","e","postMessage","err","testFileReaderSupport","crypto","subtle","digest","testNativeCryptoSupport","api","file","basePath","DEFAULT_WORKER_SCRIPT","workerScriptPath","Hasher","ready","cb_start","cb_result","cb_error","this","on","event","callback","cb_progress","hashWorker","next","reject","message","data","result","progress","undefined","error","console","trace","hashLocal","Error","size","sha256","CryptoJS","prev","algo","SHA256","create","hash","reader","onloadstart","start","onprogress","buf","target","chunkUint8","Uint8Array","wordArr","WordArray","update","loaded","total","readAsArrayBuffer","hashLocalWithNativeAPI","FileReader","onload","then","hashResult","hexString","toString","reduce","res","catch","files","WorkerSupported","i","len","hashMethod","iter","File","isReady","resolveHash","progressCallback","rejectHash","hashPromise","hasher"],"mappings":"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","file":"woleet-hashfile.min.js","sourcesContent":["/**\n * @typedef {Object}   ProgressMessage\n * @typedef {Number}   ProgressMessage.progress (float number)\n * @typedef {File}     ProgressMessage.file\n */\n\n/**\n * @typedef {Object}   StartMessage\n * @typedef {Boolean}  StartMessage.start always true\n * @typedef {File}     ProgressMessage.file\n */\n\n/**\n * @typedef {Object}   ErrorMessage\n * @typedef {Error}    ErrorMessage.error\n * @typedef {File}     EndMessage.file\n */\n\n/**\n * @typedef {Object}   EndMessage\n * @typedef {String}   EndMessage.end hash of the file\n * @typedef {File}     EndMessage.file\n */\n\n;(function (root, factory) {\n    root.woleet = factory(root.woleet)\n})(window, function (woleet) {\n\n    const testFileReaderSupport = checkFileReaderSyncSupport();\n    //noinspection JSUnresolvedVariable\n    const testNativeCryptoSupport = window.crypto && window.crypto.subtle && window.crypto.subtle.digest;\n\n    const api = woleet || {};\n    api.file = api.file || {};\n\n    /**\n     * @returns string base path (including final '/') of the current script.\n     */\n    function findBasePath() {\n        let scripts = document.getElementsByTagName('script'),\n            script = scripts[scripts.length - 1].src; // last script is always the current script\n        return script.substr(0, script.lastIndexOf(\"/\") + 1);\n    }\n\n    // Guess the path of the worker script: same as current script's or defined by woleet.workerScriptPath\n    let basePath = findBasePath();\n    let DEFAULT_WORKER_SCRIPT = \"worker.min.js\";\n    //noinspection JSUnresolvedVariable\n    let workerScriptPath = (api.workerScriptPath || (basePath ? basePath + DEFAULT_WORKER_SCRIPT : null));\n    if (!workerScriptPath)\n        throw new Error('Cannot find ' + DEFAULT_WORKER_SCRIPT);\n\n    /**\n     * Check support for workers.\n     */\n    function checkFileReaderSyncSupport() {\n\n        function makeWorker(script) {\n            //noinspection JSUnresolvedVariable\n            let URL = window.URL || window.webkitURL;\n            let Blob = window.Blob;\n            let Worker = window.Worker;\n\n            if (!URL || !Blob || !Worker || !script) return null;\n\n            let blob = new Blob([script]);\n            //noinspection JSUnresolvedFunction\n            return new Worker(URL.createObjectURL(blob));\n        }\n\n        return new Promise(function (resolve) {\n            let syncDetectionScript = \"onmessage = function(e) { postMessage(!!FileReaderSync); };\";\n            try {\n                let worker = makeWorker(syncDetectionScript);\n                if (worker) {\n                    worker.onmessage = function (e) {\n                        resolve(e.data);\n                    };\n                    worker.postMessage({});\n                }\n                else resolve(false);\n            } catch (err) {\n                resolve(false);\n            }\n        });\n    }\n\n    api.file.Hasher = function () {\n\n        let ready = true;\n        let cb_start, cb_progress, cb_result, cb_error;\n\n        /**\n         * @param {String} event\n         * @param {Function} callback\n         */\n        this.on = function (event, callback) {\n            switch (event) {\n                case 'start':\n                    cb_start = callback;\n                    break;\n                case 'progress':\n                    cb_progress = callback;\n                    break;\n                case 'error':\n                    cb_error = callback;\n                    break;\n                case 'result':\n                    cb_result = callback;\n                    break;\n                default:\n                    throw new Error('Invalid event name \"' + event + '\"');\n            }\n        };\n\n        /**\n         * @param {File} file\n         * @returns {Promise}\n         */\n        const hashWorker = function (file) {\n            return new Promise((next, reject) => {\n\n                let worker = new Worker(workerScriptPath);\n\n                worker.onmessage = function (message) {//handling worker message\n                    if (message.data.progress != undefined) {\n                        if (cb_progress) cb_progress(message.data);\n                    }\n                    else if (message.data.result) {\n                        if (cb_result) cb_result(message.data);\n                        next();\n                    }\n                    else if (message.data.start) {\n                        if (cb_start) cb_start(message.data);\n                    }\n                    else if (message.data.error) {\n                        let error = message.data.error;\n                        if (cb_error) cb_error(error);\n                        else reject(error);\n                    }\n                    else {\n                        console.trace(\"Unexpected worker message: \", message);\n                    }\n                };\n\n                worker.postMessage(file);\n            });\n        };\n\n        /**\n         * @param {File} file\n         * @returns {Promise}\n         */\n        const hashLocal = function (file) {\n\n            return new Promise((next, reject) => {\n                let err = new Error(\"file_too_big_to_be_hashed_without_worker\");\n                if (file.size > 5e7) {\n                    ready = true;\n                    if (cb_error) return cb_error({error: err, file: file});\n                    else reject(error);\n                }\n\n                let reader = new FileReader();\n\n                let sha256 = CryptoJS.algo.SHA256.create();\n                let hash, prev = 0;\n\n                reader.onloadstart = () => {\n                    if (cb_start) cb_start({start: true, file: file});\n                };\n\n                reader.onloadend = () => {\n                    hash.finalize();\n                    if (cb_result) cb_result({\n                        result: hash._hash.toString(CryptoJS.enc.Hex),\n                        file: file\n                    });\n                    next();\n                };\n\n                reader.onprogress = (e) => {\n                    //noinspection JSUnresolvedVariable\n                    /** @type ArrayBuffer */\n                    let buf = e.target.result;\n                    //noinspection JSUnresolvedVariable\n                    let blob = buf.slice(prev, e.loaded);\n                    let chunkUint8 = new Uint8Array(blob);\n                    let wordArr = CryptoJS.lib.WordArray.create(chunkUint8);\n                    hash = sha256.update(wordArr);\n                    //noinspection JSUnresolvedVariable\n                    prev = e.loaded;\n                    if (cb_progress) {\n                        //noinspection JSUnresolvedVariable\n                        cb_progress({progress: (e.loaded / e.total), file: file});\n                    }\n                };\n\n                reader.readAsArrayBuffer(file);\n            });\n        };\n\n        /**\n         * @param {File} file\n         * @returns {Promise}\n         */\n        const hashLocalWithNativeAPI = function (file) {\n            return new Promise((resolve, reject) => {\n                let algo = \"SHA-256\";\n                // entry point\n                let reader = new FileReader();\n\n                reader.onloadstart = () => {\n                    if (cb_start) cb_start({start: true, file: file});\n                };\n\n                reader.onprogress = (e) => {\n                    if (cb_progress) { //noinspection JSUnresolvedVariable\n                        cb_progress({progress: (e.loaded / e.total), file: file});\n                    }\n                };\n\n                reader.onload = function (event) {\n                    let data = event.target.result;\n                    //noinspection JSUnresolvedFunction,JSUnresolvedVariable\n                    window.crypto.subtle.digest(algo, data)\n                        .then(function (hash) {\n                            let hashResult = new Uint8Array(hash);\n                            let hexString = hashResult.reduce((res, e) => res + e.toString(16), '');\n                            if (cb_result) cb_result({result: hexString, file: file});\n                            resolve();\n                        })\n                        .catch((error) => cb_error ? cb_error({error: error, file: file}) : reject(error));\n                };\n\n                reader.readAsArrayBuffer(file);\n            })\n        };\n\n        this.start = function (files) {\n\n            if (!ready) throw new Error(\"not_ready\");\n\n            ready = false;\n\n            testFileReaderSupport\n                .then((WorkerSupported) => {\n                    let hashMethod = null;\n                    if (testNativeCryptoSupport) {\n                        hashMethod = hashLocalWithNativeAPI;\n                    }\n                    else if (WorkerSupported) {\n                        hashMethod = hashWorker;\n                    }\n                    else if (typeof CryptoJS !== 'undefined') {\n                        hashMethod = hashLocal;\n                    }\n                    else {\n                        throw new Error(\"no_viable_hash_method\");\n                    }\n\n                    // set iterator function with selected hash method\n                    function iter(i, len) {\n                        if ((i >= len)) {\n                            ready = true;\n                        }\n                        else {\n                            hashMethod(files[i]).then(() => {\n                                iter(++i, len)\n                            })\n                        }\n                    }\n\n                    // entry point\n                    if (files instanceof FileList) { // files is a FileList\n                        iter(0, files.length);\n                    }\n                    else if (files instanceof File) { // files is a single file\n                        hashMethod(files).then(() => {\n                            ready = true;\n                        })\n                    }\n                    else throw new Error(\"invalid_parameter\");\n                });\n\n        };\n\n        this.isReady = function () {\n            return ready;\n        };\n    };\n\n    /**\n     * @param {File|String} file\n     * @param {Function} [progressCallback]\n     * @returns {Promise<Hash>}\n     */\n    api._hashStringOrFile = function (file, progressCallback) {\n        let resolveHash;\n        let rejectHash;\n        let hashPromise = new Promise(function (resolve, reject) {\n            resolveHash = resolve;\n            rejectHash = reject;\n        });\n\n        if (file instanceof File) {\n\n            if (!api.file || !api.file.Hasher) throw new Error(\"missing_woleet_hash_dependency\");\n\n            let hasher = new api.file.Hasher;\n            //noinspection JSUnusedLocalSymbols\n            hasher.on('result', function (message, file) {\n                resolveHash(message.result);\n                if (progressCallback) progressCallback({progress: 1.0, file: File})\n            });\n\n            if (progressCallback && typeof progressCallback == 'function') {\n                hasher.on('progress', progressCallback);\n            }\n\n            hasher.on('error', function (error) {\n                rejectHash(error);\n            });\n\n            hasher.start(file)\n        }\n        else if (typeof file == \"string\") {\n            if (api.isSHA256(file)) {\n                //noinspection JSUnusedAssignment\n                resolveHash(file);\n            }\n            else {\n                //noinspection JSUnusedAssignment\n                rejectHash(new Error(\"parameter_string_not_a_sha256_hash\"));\n            }\n        }\n        else {\n            //noinspection JSUnusedAssignment\n            rejectHash(new Error(\"invalid_parameter\"));\n        }\n\n        return hashPromise;\n    };\n\n    return api;\n});"]}