{"version":3,"sources":["woleet-hashfile.js"],"names":["root","factory","woleet","window","findBasePath","len","scripts","document","getElementsByTagName","length","src","wolScript","match","re","split","slice","join","checkFileReaderSyncSupport","makeWorker","script","URL","webkitURL","Blob","Worker","blob","createObjectURL","Promise","syncDetectionScript","resolve","worker","onmessage","e","WORKER_LOCATION","testFileReaderSupport","api","file","Hasher","ready","cb_progress","cb_result","cb_error","this","on","event","callback","cb_start","Error","hashWorker","files","i","postMessage","item","message","data","progress","result","next","error","console","trace","hashLocal","hash","err","reader","FileReader","start","finalize","algo","SHA256","create","_hash","toString","CryptoJS","enc","Hex","onprogress","wordArr","buf","prev","loaded","Uint8Array","lib","WordArray","chunkUint8","sha256","update","readAsArrayBuffer","total","FileList","then","supported","isReady"],"mappings":"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","file":"woleet-hashfile.min.js","sourcesContent":["/**\n * @typedef {Object}   ProgressMessage\n * @typedef {Number}   ProgressMessage.progress (float number)\n * @typedef {File}     ProgressMessage.file\n */\n\n/**\n * @typedef {Object}   StartMessage\n * @typedef {Boolean}  StartMessage.start always true\n * @typedef {File}     ProgressMessage.file\n */\n\n/**\n * @typedef {Object}   ErrorMessage\n * @typedef {Error}    ErrorMessage.error\n * @typedef {File}     EndMessage.file\n */\n\n/**\n * @typedef {Object}   EndMessage\n * @typedef {String}   EndMessage.end hash of the file\n * @typedef {File}     EndMessage.file\n */\n\n;(function (root, factory) {\n    root.woleet = factory(root.woleet)\n})(window, function (woleet) {\n\n    function findBasePath () {\n        var scripts = document.getElementsByTagName('script'),\n            len = scripts.length,\n            re = /woleet-verify[.min]*\\.js$/,\n            src, wolScript;\n\n        while (src = scripts[--len].src) {\n            if (src && src.match(re)) {\n                wolScript = src;\n                break;\n            }\n        }\n\n        return wolScript ? wolScript.split('/').slice(0,-1).join('/') + '/' : null;\n    }\n\n    var WORKER_LOCATION = (woleet.path || findBasePath() || \"../dist/\") + \"worker.min.js\";\n\n    /**\n     * Check support for workers.\n     */\n    function checkFileReaderSyncSupport() {\n\n        function makeWorker(script) {\n            //noinspection JSUnresolvedVariable\n            var URL = window.URL || window.webkitURL;\n            var Blob = window.Blob;\n            var Worker = window.Worker;\n\n            if (!URL || !Blob || !Worker || !script) return null;\n\n            var blob = new Blob([script]);\n            //noinspection JSUnresolvedFunction\n            return new Worker(URL.createObjectURL(blob));\n        }\n\n        return new Promise(function(resolve){\n            var syncDetectionScript = \"onmessage = function(e) { postMessage(!!FileReaderSync); };\";\n            try {\n                var worker = makeWorker(syncDetectionScript);\n                if (worker) {\n                    worker.onmessage = function (e) {\n                        resolve(e.data);\n                    };\n                    worker.postMessage({});\n                }\n                else resolve(false);\n            } catch (err) {\n                resolve(false);\n            }\n        });\n\n    }\n\n    var testFileReaderSupport = checkFileReaderSyncSupport();\n\n    var api = woleet || {};\n    api.file = api.file || {};\n\n    api.file.Hasher = function () {\n\n        var ready = true;\n        var cb_start, cb_progress, cb_result, cb_error;\n\n        /**\n         * @param {String} event\n         * @param {Function} callback\n         */\n        this.on = function (event, callback) {\n            switch (event) {\n                case 'start' :\n                    cb_start = callback;\n                    break;\n                case 'progress' :\n                    cb_progress = callback;\n                    break;\n                case 'error' :\n                    cb_error = callback;\n                    break;\n                case 'result' :\n                    cb_result = callback;\n                    break;\n                default:\n                    throw new Error('Invalid event name \"' + event + '\"');\n            }\n        };\n\n        /**\n         * @param {FileList|File} files\n         * @param {Number} len\n         */\n        var hashWorker = function (files, len) {\n            var i = 0;\n            var worker = new Worker(WORKER_LOCATION);\n\n            worker.onmessage = function (message) {//handling worker message\n                if (message.data.progress != undefined) {\n                    if (cb_progress) cb_progress(message.data);\n                }\n                else if (message.data.result) {\n                    if (cb_result) cb_result(message.data);\n                    next();\n                }\n                else if (message.data.start) {\n                    if (cb_start) cb_start(message.data);\n                }\n                else if (message.data.error) {\n                    var error = message.data.error;\n                    if (cb_error) cb_error(error);\n                    else throw error;\n                }\n                else {\n                    console.trace(\"Unexpected worker message :\", message);\n                }\n            };\n\n            function next() {\n                if ((i >= len)) {\n                    worker.terminate();\n                    ready = true;\n                }\n                else {\n                    worker.postMessage(files.item(i));\n                    i++;\n                }\n            }\n\n            //entry point\n            if (len != -1) next();// if files is a list\n            else {\n                worker.postMessage(files);\n            }\n        };\n\n        /**\n         * @param {FileList|File} files\n         * @param {Number} len\n         */\n        var hashLocal = function (files, len) {\n            var i = 0;\n\n            /**\n             * @param {File} file\n             */\n            function hash(file) {\n                var err = new Error(\"file_too_big_to_be_hashed_without_worker\");\n                if (file.size > 5e7) {\n                    ready = true;\n                    if (cb_error) return cb_error({error: err, file: file});\n                    else throw err;\n                }\n                if (cb_start) cb_start({start: true, file: file});\n\n                var reader = new FileReader();\n\n                var sha256 = CryptoJS.algo.SHA256.create();\n                var hash, prev = 0;\n\n                reader.onloadend = function () {\n                    hash.finalize();\n                    if (cb_result) cb_result({\n                        result: hash._hash.toString(CryptoJS.enc.Hex),\n                        file: file\n                    });\n                    next();\n                };\n\n                reader.onprogress = function (e) {\n                    //noinspection JSUnresolvedVariable\n                    /** @type ArrayBuffer */\n                    var buf = e.target.result;\n                    //noinspection JSUnresolvedVariable\n                    var blob = buf.slice(prev, e.loaded);\n                    var chunkUint8 = new Uint8Array(blob);\n                    var wordArr = CryptoJS.lib.WordArray.create(chunkUint8);\n                    hash = sha256.update(wordArr);\n                    //noinspection JSUnresolvedVariable\n                    prev = e.loaded;\n                    if (cb_progress) {\n                        //noinspection JSUnresolvedVariable\n                        cb_progress({progress: (e.loaded / e.total), file: file});\n                    }\n                };\n\n                reader.readAsArrayBuffer(file);\n            }\n\n            function next() {\n                if ((i >= len)) {\n                    ready = true;\n                }\n                else {\n                    hash(files.item(i));\n                    i++;\n                }\n            }\n\n            //entry point\n            if (len != -1) next();// if files is a list\n            else {\n                hash(files);\n            }\n        };\n\n        this.start = function (files) {\n\n            if (!ready) throw new Error(\"not_ready\");\n\n            var len = -1;\n\n            if (files instanceof FileList) {\n                len = files.length;\n            }\n            else if (files instanceof File) {\n\n            }\n            else throw new Error(\"invalid_parameter\");\n\n            ready = false;\n\n            testFileReaderSupport.then(function(supported){\n                if (supported) {\n                    hashWorker(files, len);\n                }\n                else if (typeof CryptoJS !== 'undefined') {\n                    hashLocal(files, len);\n                }\n                else {\n                    throw new Error(\"no_viable_hash_method\");\n                }\n            });\n\n        };\n\n        this.isReady = function () {\n            return ready;\n        };\n    };\n\n    return api;\n\n});"]}