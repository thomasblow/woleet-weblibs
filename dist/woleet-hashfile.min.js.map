{"version":3,"sources":["woleet-hashfile.js"],"names":["root","factory","woleet","window","findBasePath","scripts","document","getElementsByTagName","scriptsArray","Array","prototype","slice","call","re","script","find","e","src","match","lastIndexOf","workerScriptPath","makeWorker","URL","webkitURL","checkFileReaderSyncSupport","Worker","Blob","createObjectURL","blob","syncDetectionScript","worker","Promise","onmessage","resolve","testFileReaderSupport","testNativeCryptoSupport","crypto","subtle","digest","api","file","basePath","console","log","DEFAULT_WORKER_SCRIPT","Hasher","ready","cb_start","cb_progress","cb_result","cb_error","this","callback","event","Error","hashWorker","next","reject","message","undefined","data","progress","result","start","error","postMessage","hashLocal","size","err","reader","FileReader","CryptoJS","SHA256","create","hash","prev","onloadend","finalize","_hash","toString","enc","Hex","onprogress","buf","loaded","target","wordArr","lib","WordArray","chunkUint8","total","readAsArrayBuffer","hashLocalWithNativeAPI","algo","onloadstart","onload","hexString","hashResult","reduce","res","then","catch","files","FileList","File","WorkerSupported","iter","i","len","hashMethod","length","isReady","_hashStringOrFile","progressCallback","resolveHash","rejectHash","hashPromise","hasher","on","isSHA256"],"mappings":"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","file":"woleet-hashfile.min.js","sourcesContent":["/**\n * @typedef {Object}   ProgressMessage\n * @typedef {Number}   ProgressMessage.progress (float number)\n * @typedef {File}     ProgressMessage.file\n */\n\n/**\n * @typedef {Object}   StartMessage\n * @typedef {Boolean}  StartMessage.start always true\n * @typedef {File}     ProgressMessage.file\n */\n\n/**\n * @typedef {Object}   ErrorMessage\n * @typedef {Error}    ErrorMessage.error\n * @typedef {File}     EndMessage.file\n */\n\n/**\n * @typedef {Object}   EndMessage\n * @typedef {String}   EndMessage.end hash of the file\n * @typedef {File}     EndMessage.file\n */\n\n;(function (root, factory) {\n    root.woleet = factory(root.woleet)\n})(window, function (woleet) {\n\n    const testFileReaderSupport = checkFileReaderSyncSupport();\n    //noinspection JSUnresolvedVariable\n    const testNativeCryptoSupport = window.crypto && window.crypto.subtle && window.crypto.subtle.digest;\n\n    const api = woleet || {};\n    api.file = api.file || {};\n\n    /**\n     * @returns string base path (including final '/') of the current script.\n     */\n    function findBasePath() {\n        let scripts = document.getElementsByTagName('script');\n        let scriptsArray = Array.prototype.slice.call(scripts, 0); // Converts collection to array\n        let re = /.*woleet-(hashfile|weblibs)[.min]*\\.js$/;\n        let script = scriptsArray.find((e) => e.src && e.src.match(re));\n\n        return script && script.src ? script.src.substr(0, script.src.lastIndexOf(\"/\") + 1) : null;\n    }\n\n    // Guess the path of the worker script: same as current script's or defined by woleet.workerScriptPath\n    let basePath = findBasePath();\n    console.log(basePath);\n    let DEFAULT_WORKER_SCRIPT = \"woleet-hashfile-worker.min.js\";\n    //noinspection JSUnresolvedVariable\n    let workerScriptPath = (api.workerScriptPath || (basePath ? basePath + DEFAULT_WORKER_SCRIPT : null));\n    if (!workerScriptPath)\n        throw new Error('Cannot find ' + DEFAULT_WORKER_SCRIPT);\n\n    /**\n     * Check support for workers.\n     */\n    function checkFileReaderSyncSupport() {\n\n        function makeWorker(script) {\n            //noinspection JSUnresolvedVariable\n            let URL = window.URL || window.webkitURL;\n            let Blob = window.Blob;\n            let Worker = window.Worker;\n\n            if (!URL || !Blob || !Worker || !script) return null;\n\n            let blob = new Blob([script]);\n            //noinspection JSUnresolvedFunction\n            return new Worker(URL.createObjectURL(blob));\n        }\n\n        return new Promise(function (resolve) {\n            let syncDetectionScript = \"onmessage = function(e) { postMessage(!!FileReaderSync); };\";\n            try {\n                let worker = makeWorker(syncDetectionScript);\n                if (worker) {\n                    worker.onmessage = function (e) {\n                        resolve(e.data);\n                    };\n                    worker.postMessage({});\n                }\n                else resolve(false);\n            } catch (err) {\n                resolve(false);\n            }\n        });\n    }\n\n    api.file.Hasher = function () {\n\n        let ready = true;\n        let cb_start, cb_progress, cb_result, cb_error;\n\n        /**\n         * @param {String} event\n         * @param {Function} callback\n         */\n        this.on = function (event, callback) {\n            switch (event) {\n                case 'start':\n                    cb_start = callback;\n                    break;\n                case 'progress':\n                    cb_progress = callback;\n                    break;\n                case 'error':\n                    cb_error = callback;\n                    break;\n                case 'result':\n                    cb_result = callback;\n                    break;\n                default:\n                    throw new Error('Invalid event name \"' + event + '\"');\n            }\n        };\n\n        /**\n         * @param {File} file\n         * @returns {Promise}\n         */\n        const hashWorker = function (file) {\n            return new Promise((next, reject) => {\n\n                let worker = new Worker(workerScriptPath);\n\n                worker.onmessage = function (message) {//handling worker message\n                    if (message.data.progress != undefined) {\n                        if (cb_progress) cb_progress(message.data);\n                    }\n                    else if (message.data.result) {\n                        if (cb_result) cb_result(message.data);\n                        next();\n                    }\n                    else if (message.data.start) {\n                        if (cb_start) cb_start(message.data);\n                    }\n                    else if (message.data.error) {\n                        let error = message.data.error;\n                        if (cb_error) cb_error(error);\n                        else reject(error);\n                    }\n                    else {\n                        console.trace(\"Unexpected worker message: \", message);\n                    }\n                };\n\n                worker.postMessage(file);\n            });\n        };\n\n        /**\n         * @param {File} file\n         * @returns {Promise}\n         */\n        const hashLocal = function (file) {\n\n            return new Promise((next, reject) => {\n                let err = new Error(\"file_too_big_to_be_hashed_without_worker\");\n                if (file.size > 5e7) {\n                    ready = true;\n                    if (cb_error) return cb_error({error: err, file: file});\n                    else reject(error);\n                }\n\n                let reader = new FileReader();\n\n                let sha256 = CryptoJS.algo.SHA256.create();\n                let hash, prev = 0;\n\n                reader.onloadstart = () => {\n                    if (cb_start) cb_start({start: true, file: file});\n                };\n\n                reader.onloadend = () => {\n                    hash.finalize();\n                    if (cb_result) cb_result({\n                        result: hash._hash.toString(CryptoJS.enc.Hex),\n                        file: file\n                    });\n                    next();\n                };\n\n                reader.onprogress = (e) => {\n                    //noinspection JSUnresolvedVariable\n                    /** @type ArrayBuffer */\n                    let buf = e.target.result;\n                    //noinspection JSUnresolvedVariable\n                    let blob = buf.slice(prev, e.loaded);\n                    let chunkUint8 = new Uint8Array(blob);\n                    let wordArr = CryptoJS.lib.WordArray.create(chunkUint8);\n                    hash = sha256.update(wordArr);\n                    //noinspection JSUnresolvedVariable\n                    prev = e.loaded;\n                    if (cb_progress) {\n                        //noinspection JSUnresolvedVariable\n                        cb_progress({progress: (e.loaded / e.total), file: file});\n                    }\n                };\n\n                reader.readAsArrayBuffer(file);\n            });\n        };\n\n        /**\n         * @param {File} file\n         * @returns {Promise}\n         */\n        const hashLocalWithNativeAPI = function (file) {\n            return new Promise((resolve, reject) => {\n                let algo = \"SHA-256\";\n                // entry point\n                let reader = new FileReader();\n\n                reader.onloadstart = () => {\n                    if (cb_start) cb_start({start: true, file: file});\n                };\n\n                reader.onprogress = (e) => {\n                    if (cb_progress) { //noinspection JSUnresolvedVariable\n                        cb_progress({progress: (e.loaded / e.total), file: file});\n                    }\n                };\n\n                reader.onload = function (event) {\n                    let data = event.target.result;\n                    //noinspection JSUnresolvedFunction,JSUnresolvedVariable\n                    window.crypto.subtle.digest(algo, data)\n                        .then(function (hash) {\n                            let hashResult = new Uint8Array(hash);\n                            let hexString = hashResult.reduce((res, e) => res + ('00' + e.toString(16)).slice(-2), '');\n                            if (cb_result) cb_result({result: hexString, file: file});\n                            resolve();\n                        })\n                        .catch((error) => cb_error ? cb_error({error: error, file: file}) : reject(error));\n                };\n\n                reader.readAsArrayBuffer(file);\n            })\n        };\n\n        this.start = function (files) {\n\n            if (!ready) throw new Error(\"not_ready\");\n\n            ready = false;\n\n            // checking input type\n            if (!(files instanceof FileList || files instanceof File))\n                throw new Error(\"invalid_parameter\");\n\n            testFileReaderSupport\n                .then((WorkerSupported) => {\n                    let hashMethod = null;\n                    if (testNativeCryptoSupport) {\n                        hashMethod = hashLocalWithNativeAPI;\n                    }\n                    else if (WorkerSupported) {\n                        hashMethod = hashWorker;\n                    }\n                    else if (typeof CryptoJS !== 'undefined') {\n                        hashMethod = hashLocal;\n                    }\n                    else {\n                        throw new Error(\"no_viable_hash_method\");\n                    }\n\n                    // set iterator function with selected hash method\n                    function iter(i, len) {\n                        if ((i >= len)) {\n                            ready = true;\n                        }\n                        else {\n                            hashMethod(files[i]).then(() => {\n                                iter(++i, len)\n                            })\n                        }\n                    }\n\n                    console.log(\"files is\", files instanceof FileList, files instanceof File, typeof files);\n\n                    // entry point\n                    if (files instanceof FileList) { // files is a FileList\n                        console.log('iter file');\n                        iter(0, files.length);\n                    }\n                    else if (files instanceof File) { // files is a single file\n                        console.log('iter files');\n                        hashMethod(files).then(() => {\n                            ready = true;\n                        })\n                    }\n                })\n\n        };\n\n        this.isReady = function () {\n            return ready;\n        };\n    };\n\n    /**\n     * @param {File|String} file\n     * @param {Function} [progressCallback]\n     * @returns {Promise<Hash>}\n     */\n    api._hashStringOrFile = function (file, progressCallback) {\n        let resolveHash;\n        let rejectHash;\n        let hashPromise = new Promise(function (resolve, reject) {\n            resolveHash = resolve;\n            rejectHash = reject;\n        });\n\n        if (file instanceof File) {\n\n            if (!api.file || !api.file.Hasher) throw new Error(\"missing_woleet_hash_dependency\");\n\n            let hasher = new api.file.Hasher;\n            //noinspection JSUnusedLocalSymbols\n            hasher.on('result', function (message, file) {\n                resolveHash(message.result);\n                if (progressCallback) progressCallback({progress: 1.0, file: File})\n            });\n\n            if (progressCallback && typeof progressCallback == 'function') {\n                hasher.on('progress', progressCallback);\n            }\n\n            hasher.on('error', function (error) {\n                rejectHash(error);\n            });\n\n            hasher.start(file)\n        }\n        else if (typeof file == \"string\") {\n            if (api.isSHA256(file)) {\n                //noinspection JSUnusedAssignment\n                resolveHash(file);\n            }\n            else {\n                //noinspection JSUnusedAssignment\n                rejectHash(new Error(\"parameter_string_not_a_sha256_hash\"));\n            }\n        }\n        else {\n            //noinspection JSUnusedAssignment\n            rejectHash(new Error(\"invalid_parameter\"));\n        }\n\n        return hashPromise;\n    };\n\n    return api;\n});"]}