{"version":3,"sources":["woleet-hashfile-worker.js"],"names":["importScripts","self","addEventListener","e","file","data","postMessage","start","hash","maxBlockSize","hashByBlock","_maxBlockSize","readSlicer","fileSlicer","chunk","chunkUint8","sha256","CryptoJS","algo","SHA256","create","totalFileSize","size","stop","FileReaderSync","slice","progress","readAsArrayBuffer","Uint8Array","wordArr","lib","WordArray","update","finalize","_hash","toString","enc","Hex","hashChunk","reader","blob","result","err","error"],"mappings":"AACAA,cAAc,iBAMdC,KAAKC,iBAAiB,UAAW,SAAUC,GAEvC,GAAIC,GAAOD,EAAEE,IAGbC,cAAaC,OAAO,EAAMH,KAAMA,GAChC,IA2DII,GA3DAC,EAAe,IAEfC,EAAc,SAAUN,EAAMO,GAa9B,IAZA,GAMIH,GACAI,EACAC,EACAC,EACAC,EAVAN,EAAeE,GAAiB,SAChCK,EAASC,SAASC,KAAKC,OAAOC,SAE9BC,EAAgBjB,EAAKkB,KACrBf,EAAQ,EACRgB,EAAOd,IAOE,CAETG,EAAa,GAAIY,gBACjBX,EAAaT,EAAKqB,MAAMlB,EAAOgB,GAE/BjB,aAAaoB,SAAUnB,EAAQH,EAAKkB,KAAMlB,KAAMA,IAEhDU,EAAQF,EAAWe,kBAAkBd,GACrCE,EAAa,GAAIa,YAAWd,EAC5B,IAAIe,GAAUZ,SAASa,IAAIC,UAAUX,OAAOL,EAgB5C,IAfAP,EAAOQ,EAAOgB,OAAOH,GAGrBf,EAAQ,KACRC,EAAa,KACbc,EAAU,KACVjB,EAAa,KAMbL,EAAQgB,EACRA,GAAQd,EAEJF,GAASc,EAET,MADAb,GAAKyB,WACEzB,EAAK0B,MAAMC,SAASlB,SAASmB,IAAIC,OAKhDC,EAAY,SAAUlC,GACtB,GAAIG,GAAQ,EACRgB,EAAOnB,EAAKkB,KAEZiB,EAAS,GAAIf,gBACbgB,EAAOpC,EAAKqB,MAAMlB,EAAOgB,GACzBT,EAAQyB,EAAOZ,kBAAkBa,GACjCzB,EAAa,GAAIa,YAAWd,GAC5Be,EAAUZ,SAASa,IAAIC,UAAUX,OAAOL,EAC5C,OAAQE,UAASE,OAAOU,GAAUM,WAKtC,KAEQ3B,EADAJ,EAAKkB,KAAOb,EACLC,EAAYN,GAGZkC,EAAUlC,GAGrBE,aAAamC,OAAQjC,EAAMJ,KAAMA,IACnC,MAAOsC,GAELpC,aAAaqC,MAAOD,EAAKtC,KAAMA,IACjC,YAGH","file":"woleet-hashfile-worker.min.js","sourcesContent":["/* crypto-js lib: minified version */\r\nimportScripts('crypto.min.js');\r\n/* crypto-js lib: regular version */\r\n//importScripts('bower_components/crypto-js/core.js');\r\n//importScripts('bower_components/crypto-js/lib-typedarrays.js');\r\n//importScripts('bower_components/crypto-js/sha256.js');\r\n\r\nself.addEventListener('message', function (e) {\r\n\r\n    var file = e.data;\r\n\r\n    //noinspection JSUnresolvedFunction\r\n    postMessage({start: true, file: file});\r\n    var maxBlockSize = 1e7;\r\n\r\n    var hashByBlock = function (file, _maxBlockSize) {\r\n        var maxBlockSize = _maxBlockSize || 0xffffff;\r\n        var sha256 = CryptoJS.algo.SHA256.create();\r\n\r\n        var totalFileSize = file.size,\r\n            start = 0,\r\n            stop = maxBlockSize,\r\n            hash,\r\n            readSlicer,\r\n            fileSlicer,\r\n            chunk,\r\n            chunkUint8;\r\n\r\n        while (true) {\r\n            //noinspection JSUnresolvedFunction\r\n            readSlicer = new FileReaderSync();\r\n            fileSlicer = file.slice(start, stop);\r\n            //noinspection JSUnresolvedFunction\r\n            postMessage({progress: start / file.size, file: file});\r\n\r\n            chunk = readSlicer.readAsArrayBuffer(fileSlicer);\r\n            chunkUint8 = new Uint8Array(chunk);\r\n            var wordArr = CryptoJS.lib.WordArray.create(chunkUint8);\r\n            hash = sha256.update(wordArr);\r\n\r\n            /* Helps the interpreter to free memory */\r\n            chunk = null;\r\n            chunkUint8 = null;\r\n            wordArr = null;\r\n            readSlicer = null;\r\n\r\n            /* Checks if file hash is done or not\r\n             * if so, finalise hash\r\n             * else increase block offset */\r\n\r\n            start = stop;\r\n            stop += maxBlockSize;\r\n\r\n            if (start >= totalFileSize) {\r\n                hash.finalize();\r\n                return hash._hash.toString(CryptoJS.enc.Hex);\r\n            }\r\n        }\r\n    };\r\n\r\n    var hashChunk = function (file) {\r\n        var start = 0;\r\n        var stop = file.size;\r\n        //noinspection JSUnresolvedFunction\r\n        var reader = new FileReaderSync();\r\n        var blob = file.slice(start, stop);\r\n        var chunk = reader.readAsArrayBuffer(blob);\r\n        var chunkUint8 = new Uint8Array(chunk);\r\n        var wordArr = CryptoJS.lib.WordArray.create(chunkUint8);\r\n        return (CryptoJS.SHA256(wordArr)).toString();\r\n    };\r\n\r\n    var hash;\r\n\r\n    try {\r\n        if (file.size > maxBlockSize) {\r\n            hash = hashByBlock(file);\r\n        }\r\n        else {\r\n            hash = hashChunk(file);\r\n        }\r\n        //noinspection JSUnresolvedFunction\r\n        postMessage({result: hash, file: file});\r\n    } catch (err) {\r\n        //noinspection JSUnresolvedFunction\r\n        postMessage({error: err, file: file});\r\n    } finally {\r\n        //close();\r\n    }\r\n}, false);"]}