{"version":3,"sources":["woleet-chainpoint.js"],"names":["root","factory","woleet","window","MerkleBranch","left","right","hash_f","_hash_f","sha256","_left","_right","_parent","this","get_parent","contains","target","get_json","parent","MerkleProof","self","branches","add","branch","push","is_valid","new_target","length","i","json_data","forEach","R","n","x","F0","F1","S0","S1","Ch","y","z","Maj","msg","K","H","fromCharCode","l","N","ceil","M","String","lenHi","j","charCodeAt","Array","lenLo","Math","floor","pow","t","W","b","c","d","g","e","f","h","T1","a","T2","toString","slice","join","api","receipt","validate","target_hash","target_proof","Error","merkle_root","header","tx_id","isSHA256","proof","merkleBranch"],"mappings":"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","file":"woleet-chainpoint.min.js","sourcesContent":["/**\n * @typedef {Object}   Leaf\n * @typedef {Hash}     Leaf.left\n * @typedef {Hash}     Leaf.right\n * @typedef {Hash}     Leaf.parent\n */\n\n/**\n * @typedef {Object}   Receipt\n * @typedef {Object}   Receipt.header\n * @typedef {String}   Receipt.header.chainpoint_version\n * @typedef {String}   Receipt.header.hash_type\n * @typedef {String}   Receipt.header.merkle_root\n * @typedef {String}   Receipt.header.tx_id\n * @typedef {String}   Receipt.header.timestamp\n * @typedef {Object}   Receipt.target\n * @typedef {String}   Receipt.target.target_hash\n * @typedef {String}   Receipt.target.target_URI\n * @typedef {Leaf[]}   Receipt.target.target_proof\n * @typedef {Object[]} Receipt.extra\n */\n\n;(function (root, factory) {\n    root.woleet = factory(root.woleet)\n})(window, function (woleet) {\n\n    /**\n     * @typedef {String} Hash\n     * @typedef {function(String): Hash} HashFunction\n     */\n\n    /**\n     * @type HashFunction\n     * @param {String} content\n     * @returns {Hash}\n     */\n\n    var sha256 = (function () {\n\n        /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n        /* SHA-256 (FIPS 180-4) implementation in JavaScript                  (c) Chris Veness 2002-2016  */\n        /*                                                                                   MIT Licence  */\n        /* www.movable-type.co.uk/scripts/sha256.html                                                     */\n        /*                                                                                                */\n        /*  - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html                              */\n        /*        http://csrc.nist.gov/groups/ST/toolkit/examples.html                                    */\n        /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n        'use strict';\n\n        function R(n, x) {\n            //noinspection JSConstructorReturnsPrimitive\n            return (x >>> n) | (x << (32 - n));\n        }\n\n        function F0(x) {\n            //noinspection JSConstructorReturnsPrimitive\n            return R(2, x) ^ R(13, x) ^ R(22, x);\n        }\n\n        function F1(x) {\n            //noinspection JSConstructorReturnsPrimitive\n            return R(6, x) ^ R(11, x) ^ R(25, x);\n        }\n\n        function S0(x) {\n            //noinspection JSConstructorReturnsPrimitive\n            return R(7, x) ^ R(18, x) ^ (x >>> 3);\n        }\n\n        function S1(x) {\n            //noinspection JSConstructorReturnsPrimitive\n            return R(17, x) ^ R(19, x) ^ (x >>> 10);\n        }\n\n        function Ch(x, y, z) {\n            //noinspection JSConstructorReturnsPrimitive\n            return (x & y) ^ (~x & z);\n        }\n\n        function Maj(x, y, z) {\n            //noinspection JSConstructorReturnsPrimitive\n            return (x & y) ^ (x & z) ^ (y & z);\n        }\n\n        return function (msg) {\n            var K = [\n                0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n                0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n                0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n                0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n                0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n                0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n                0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n                0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n\n            var H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];\n\n            msg += String.fromCharCode(0x80);\n            var l = msg.length / 4 + 2;\n            var N = Math.ceil(l / 16);\n            var M = new Array(N);\n\n            for (var i = 0; i < N; i++) {\n                M[i] = new Array(16);\n                for (var j = 0; j < 16; j++) {\n                    M[i][j] = (msg.charCodeAt(i * 64 + j * 4) << 24) | (msg.charCodeAt(i * 64 + j * 4 + 1) << 16) |\n                        (msg.charCodeAt(i * 64 + j * 4 + 2) << 8) | (msg.charCodeAt(i * 64 + j * 4 + 3));\n                }\n            }\n            var lenHi = ((msg.length - 1) * 8) / Math.pow(2, 32);\n            var lenLo = ((msg.length - 1) * 8) >>> 0;\n            M[N - 1][14] = Math.floor(lenHi);\n            M[N - 1][15] = lenLo;\n\n            for (let i = 0; i < N; i++) {\n                let W = new Array(64);\n\n                for (let t = 0; t < 16; t++) W[t] = M[i][t];\n                for (let t = 16; t < 64; t++) {\n                    W[t] = (S1(W[t - 2]) + W[t - 7] + S0(W[t - 15]) + W[t - 16]) >>> 0;\n                }\n\n                let a = H[0], b = H[1], c = H[2], d = H[3], e = H[4], f = H[5], g = H[6], h = H[7];\n\n                for (let t = 0; t < 64; t++) {\n                    var T1 = h + F1(e) + Ch(e, f, g) + K[t] + W[t];\n                    var T2 = F0(a) + Maj(a, b, c);\n                    h = g;\n                    g = f;\n                    f = e;\n                    e = (d + T1) >>> 0;\n                    d = c;\n                    c = b;\n                    b = a;\n                    a = (T1 + T2) >>> 0;\n                }\n\n                H[0] = (H[0] + a) >>> 0;\n                H[1] = (H[1] + b) >>> 0;\n                H[2] = (H[2] + c) >>> 0;\n                H[3] = (H[3] + d) >>> 0;\n                H[4] = (H[4] + e) >>> 0;\n                H[5] = (H[5] + f) >>> 0;\n                H[6] = (H[6] + g) >>> 0;\n                H[7] = (H[7] + h) >>> 0;\n            }\n\n            for (var h = 0; h < H.length; h++) H[h] = ('00000000' + H[h].toString(16)).slice(-8);\n\n            return H.join('');\n        };\n    }());\n\n    /**\n     * Build a Merkle branch.\n     * @param {Hash} left\n     * @param {Hash} right\n     * @param {HashFunction} [hash_f]\n     * @constructor\n     */\n    function MerkleBranch(left, right, hash_f) {\n        /**\n         * @type {function(String): Hash}\n         */\n        var _hash_f = hash_f || sha256;\n        /***\n         * @type {Hash}\n         */\n        var _left = left;\n        /**\n         * @type {Hash}\n         */\n        var _right = right;\n        /**\n         * @type {Hash}\n         */\n        var _parent = _hash_f(_left + _right);\n\n        /**\n         * Get the parent of the branch.\n         * @returns {Hash}\n         */\n        this.get_parent = function () {\n            return _parent;\n        };\n\n        /**\n         * Check if a branch contains a hash.\n         * @param {Hash} target\n         * @returns {boolean}\n         */\n        this.contains = function (target) {\n            return _left == target || _right == target;\n        };\n\n        /**\n         * @returns {{parent: Hash, left: Hash, right: Hash}}\n         */\n        this.get_json = function () {\n            return {\n                \"parent\": _parent,\n                \"left\": _left,\n                \"right\": _right\n            }\n        };\n    }\n\n    /**\n     * Builds a Merkle proof.\n     * @param {String} target\n     * @param {Function} [hash_f]\n     * @constructor\n     */\n    function MerkleProof(target, hash_f) {\n        var self = this;\n\n        //noinspection JSUnusedGlobalSymbols\n        this.hash_f = hash_f || sha256;\n        this.branches = [];\n        this.target = target;\n\n        /**\n         * Add a branch to the proof.\n         * @param {MerkleBranch} branch\n         */\n        this.add = function (branch) {\n            self.branches.push(branch);\n        };\n\n        /**\n         * Returns the Merkle proof root if the proof is valid, false if it's not\n         * @returns {String|Boolean}\n         */\n        this.is_valid = function () {\n\n            // Check if the target hash is in the proof (we assume that the leaf is contained in the\n            // first branch of the proof) and if the parent of each branch is contained in its higher branch.\n\n            var new_target = self.target;\n\n            if (!self.branches.length) return false;\n\n            for (var i = 0, branch; i < self.branches.length; i++) {\n                branch = self.branches[i];\n                if (!(branch.contains(new_target))) {\n                    return false;\n                }\n                new_target = branch.get_parent();\n            }\n\n            return new_target;\n        };\n\n        // MerkleProof to machine readable JSON.\n        this.get_json = function () {\n            var json_data = [];\n            self.branches.forEach(function (branch) {\n                json_data.push(branch.get_json());\n            });\n            return (json_data);\n        };\n    }\n\n    var api = woleet || {};\n    api.receipt = api.receipt || {};\n\n    /**\n     * Validate a receipt.\n     * @param {Receipt} receipt\n     * @returns {Boolean} true if the receipt is valid\n     */\n    api.receipt.validate = function (receipt) {\n\n        if (!receipt || !receipt.target || !receipt.target.target_hash || !receipt.target.target_proof\n            || !(receipt.target.target_proof instanceof Array) || !receipt.header || !receipt.header.hash_type\n            || !receipt.header.merkle_root || !receipt.header.tx_id) {\n            throw new Error(\"invalid_receipt_format\");\n        }\n\n        for (var i = 0; i < receipt.target.target_proof.length; i++) {\n            var branch = receipt.target.target_proof[i];\n            if (!branch.left || !branch.right || !branch.parent) {\n                throw new Error(\"invalid_target_proof\");\n            }\n            if (!api.isSHA256(branch.left) || !api.isSHA256(branch.right) || !api.isSHA256(branch.parent)) {\n                throw new Error(\"non_sha256_target_proof_element\");\n            }\n        }\n\n        // If no Merkle proof\n        if (receipt.target.target_proof.length == 0) {\n\n            // Receipt is valid if its target hash is equal to its Merkle root\n            if (receipt.target.target_hash == receipt.header.merkle_root) return true;\n            else throw new Error(\"merkle_root_mismatch\");\n        }\n\n        // If there is a Merkle proof\n        else {\n\n            // Build the Merkle proof while checking its integrity\n            var proof = new MerkleProof(receipt.target.target_hash);\n            receipt.target.target_proof.forEach(function (branch) {\n\n                // Build a new Merkle branch\n                var merkleBranch = new MerkleBranch(branch.left, branch.right);\n\n                // Check that provided parent is correctly computed\n                if (!merkleBranch.get_parent() == branch.parent) {\n                    throw new Error(\"invalid_parent_in_proof_element\");\n                }\n\n                // Add Merkle branch to the Merkle proof\n                proof.add(merkleBranch);\n            });\n\n            // Receipt is valid if its Merkle root is equal to the Merkle proof root\n            if (proof.is_valid() == receipt.header.merkle_root) return true;\n            else throw new Error(\"merkle_root_mismatch\");\n        }\n    };\n\n    return api;\n});\n\n"]}