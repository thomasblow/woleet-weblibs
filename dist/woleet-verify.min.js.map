{"version":3,"sources":["woleet-verify.js"],"names":["root","factory","woleet","window","resolveHash","resolve","progressCallback","rejectHash","hashPromise","Promise","reject","file","File","hasher","api","Hasher","message","Error","on","result","progress","isSHA256","receipt","verify","WoleetDAB","then","hash","anchor","getAnchorIDs","receiptArray","anchorIDsPage","content","reduce","chain","anchorId","get","push","error","length","receiptsCheckOk","map","validate","receiptsOk","every","e","finalArray","transaction","header","tx_id","tx","confirmedOn","DAB","hashStringOrFile","target","setDefaultProvider","catch","confirmations","merkle_root"],"mappings":"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","file":"woleet-verify.min.js","sourcesContent":[";(function (root, factory) {\n    root.woleet = factory(root.woleet)\n})(window, function (woleet) {\n\n    const api = woleet || {};\n    api.receipt = api.receipt || {};\n    api.anchor = api.anchor || {};\n    api.verify = api.verify || {};\n\n    /**\n     * @param {File|String} file\n     * @param {Function} [progressCallback]\n     * @returns {Promise.<Object[]>}\n     */\n    api.verify.WoleetDAB = function (file, progressCallback) {\n\n        return hashStringOrFile(file, progressCallback)\n\n        // We get the hash, so now we get the corresponding anchor ids\n            .then((hash) => api.anchor.getAnchorIDs(hash))\n\n            // We got ids (an array), for each of them, we get the corresponding receipts\n            .then((anchorIDsPage) => {\n                const receiptArray = [];\n                return anchorIDsPage.content.reduce((chain, anchorId) => {\n                    return chain.then(() => {\n                        return api.receipt.get(anchorId)\n                            .then((receipt) => receiptArray.push(receipt))\n                            .catch((error) => {\n                                // if we cannot get the corresponding receipt for\n                                // this anchorID because it's not yet processed (202)\n                                // we ignore this element, else we forward error\n                                if (error.code != 202) throw error;\n                            })\n                    })\n                }, Promise.resolve())\n\n                // We got a receipt array, so we forward it\n                    .then(() => {\n                        // if we had a match but can't get a receipt\n                        if (!receiptArray.length && anchorIDsPage.content.length) {\n                            throw new Error('file_matched_but_anchor_not_yet_processed')\n                        }\n\n                        return receiptArray;\n                    });\n\n            })\n\n            .then((receiptArray) => {\n\n                // We check each receipt we got\n                const receiptsCheckOk = receiptArray.map((receipt) => {\n                    try {\n                        return api.receipt.validate(receipt);\n                    } catch (err) {\n                        return false;\n                    }\n                });\n\n                // We check that all of them are correct\n                const receiptsOk = receiptsCheckOk.every((e) => e == true);\n\n                const finalArray = [];\n\n                // If so, we get the corresponding transaction\n                if (receiptsOk) {\n                    return receiptArray.reduce((chain, receipt) => {\n                        return chain.then(() => {\n                            return api.transaction.get(receipt.header.tx_id).then((tx) => {\n                                finalArray.push({\n                                    receipt: receipt,\n                                    confirmations: tx.confirmations,\n                                    confirmedOn: tx.confirmedOn\n                                })\n                            })\n                        })\n                    }, Promise.resolve())\n\n                    // We got a array of object with {receipt, confirmations, confirmedOn}, so we forward it\n                        .then(() => finalArray)\n                }\n                else {\n                    throw new Error(\"invalid_receipt\");\n                }\n            })\n    };\n\n    /**\n     * @param {File|String} file\n     * @param {Receipt} receipt\n     * @param {Function} [progressCallback]\n     * @returns {Promise<Object>}\n     */\n    api.verify.DAB = function (file, receipt, progressCallback) {\n\n        return hashStringOrFile(file, progressCallback)\n            .then((hash) => {\n                api.receipt.validate(receipt);\n\n                if (receipt.target.target_hash != hash) throw new Error(\"target_hash_mismatch\");\n\n                return api.transaction.get(receipt.header.tx_id)\n                    .catch((error) => {\n                        if (error.message == 'tx_not_found') {\n                            throw error;\n                        }\n                        else {\n                            // we try a second time with a different provider\n                            api.transaction.setDefaultProvider('blockcypher.com');\n                            return api.transaction.get(receipt.header.tx_id);\n                        }\n                    })\n                    .catch((error) => {\n                        if (error.message == 'tx_not_found') {\n                            throw error;\n                        }\n                        else {\n                            throw new Error(\"error_while_getting_transaction\");\n                        }\n                    })\n            })\n            .then((tx) => {\n                if (tx.opReturn == receipt.header.merkle_root)\n                    return {\n                        receipt: receipt,\n                        confirmations: tx.confirmations,\n                        confirmedOn: tx.confirmedOn\n                    }; // opReturn matches root\n                else\n                    throw new Error('opReturn_mismatches_merkleRoot')\n            })\n    };\n\n    /**\n     * @param {File|String} file\n     * @param {Function} [progressCallback]\n     * @returns {Promise<Hash>}\n     */\n    function hashStringOrFile(file, progressCallback) {\n        let resolveHash;\n        let rejectHash;\n        const hashPromise = new Promise((resolve, reject) => {\n            resolveHash = resolve;\n            rejectHash = reject;\n        });\n\n        if (file instanceof File) {\n\n            if (!api.file || !api.file.Hasher) throw new Error(\"missing_woleet_hash_dependency\");\n\n            const hasher = new api.file.Hasher;\n            //noinspection JSUnusedLocalSymbols\n            hasher.on('result', function (message, file) {\n                resolveHash(message.result);\n                if (progressCallback) progressCallback({progress: 1.0, file: File})\n            });\n\n            if (progressCallback && typeof progressCallback == 'function') {\n                hasher.on('progress', progressCallback);\n            }\n\n            hasher.on('error', rejectHash);\n\n            hasher.start(file)\n        }\n        else if (typeof file == \"string\") {\n            if (api.isSHA256(file)) {\n                //noinspection JSUnusedAssignment\n                resolveHash(file);\n            }\n            else {\n                //noinspection JSUnusedAssignment\n                rejectHash(new Error(\"parameter_string_not_a_sha256_hash\"));\n            }\n        }\n        else {\n            //noinspection JSUnusedAssignment\n            rejectHash(new Error(\"invalid_parameter\"));\n        }\n\n        return hashPromise;\n    }\n\n    return api;\n});"]}