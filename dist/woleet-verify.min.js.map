{"version":3,"sources":["woleet-verify.js"],"names":["root","factory","woleet","window","api","receipt","verify","WoleetDAB","file","progressCallback","then","hash","anchor","getAnchorIDs","receiptArray","anchorIDsPage","content","reduce","chain","anchorId","get","push","error","Promise","resolve","length","Error","receiptsCheckOk","map","validate","err","receiptsOk","every","e","transaction","header","tx_id","tx","opReturn","merkle_root","finalArray","confirmedOn","DAB","hashFileOrCheckHash","target","target_hash","catch","setDefaultProvider","message","confirmations"],"mappings":"cAAC,SAAWA,EAAMC,GACdD,EAAKE,OAASD,EAAQD,EAAKE,SAD7BC,OAAA,SAAgBF,GAEfE,GAFFC,GAEUF,KAFV,OAKGE,GAAIC,QAAUD,EAAIC,YADlBD,EAAMA,OAAMF,EAAAA,WACZE,EAAIC,OAAJD,EAAcA,WASdA,EAAIE,OAAOC,UAAY,SAAUC,EAAMC,GAAnCH,MAAOC,GAAAA,oBAAsBC,EAAMC,GAK9BC,KAAK,SAACC,GAAD,MAAUP,GAAIQ,OAAOC,aAAaF,KAAlCD,KAAA,SAAUN,GAEhB,GAAAU,KACM,OAAAC,GAAAC,QAAmBC,OAAA,SAAAC,EAAAC,GAKjB,MAAOD,GAAMR,KAAK,WAHtB,MAAAN,GAAAC,QAAAe,IAAAD,GACML,KAAN,SAAAT,GAAA,MAAAS,GAAAO,KAAAhB,KACOU,MAAcC,SAAAA,GAIF,GAAW,KAAXM,EAACA,KAAU,KAAAA,QAGdC,QAAAC,WANZd,KAAA,WAeI,IAAKI,EAAaW,QAAUV,EAAcC,QAAQS,OAH1D,KAAA,IAAAC,OAAA,4CAGaZ,OAAAA,OAhBNJ,KAAP,SAAAI,GAwBJ,GAAAa,GAAAb,EAAAc,IAAA,SAAAvB,GACM,IAGIsB,MADNvB,GAAAC,QAAAwB,SAAAxB,IACMsB,EACE,MAAAG,GACA,OAAA,KAKHC,EAAAJ,EAAAK,MAAA,SAAAC,GAAA,MAAA,IAAAA,GAPL,IAAAF,EAAA,CAWMA,GAAAA,KAAmC,OAAOE,GAAPhB,OAAA,SAAAC,EAAAb,GAAzC,MAAAa,GAAAR,KAAA,WAGI,MAAAN,GAAA8B,YAAAd,IAAAf,EAAA8B,OAAAC,OAAA1B,KAAA,SAAA2B,GAGWnB,GAAMR,EAAK4B,UAAMjC,EAAA8B,OAAAI,YAQRlC,KAAAA,IAASA,OADG,iCAAhBmC,GAAWnB,MALnBhB,QAAAA,EACW6B,cAAgB7B,EAAAA,cAOfoC,YAAaJ,EAAGI,mBAHJlB,QAAAC,WAP5Bd,KAAA,WAAA,MAAA8B,KAmBJ,KAAA,IAAAd,OAAA,sBAehBtB,EAAIE,OAAOoC,IAAM,SAAUlC,EAAMH,EAASI,GAEtC,MAAOL,GAAIuC,oBAAoBnC,EAAMC,GAFrCH,KAAJ,SAAAK,GAWY,GAHAP,EAAIC,QAAQwB,SAASxB,GAGjBA,EAAQuC,OAAOC,aAAelC,EAAM,KAAM,IAAIe,OAAM,uBAGxD,OAAOtB,GAAI8B,YAAYd,IAAIf,EAAQ8B,OAAOC,OAJ1CU,MAAA,SAAAxB,GACYsB,GAAR,gBAAQA,EAAOC,QAMP,KAAMvB,EAEL,OAFKA,GAANY,YAAAa,mBAAA,mBAEC3C,EAAA8B,YAAAd,IAAAf,EAAA8B,OAAAC,SAGDU,MAAO1C,SAAAA,GACV,KAAA,gBAAAkB,EAAA0B,QAEG1B,EAIC,GAAAI,OAAA,uCAMjBhB,KAAA,SAAA2B,GAGI,GAAAA,EAAAC,UAAAjC,EAAA8B,OAAAI,YAGA,OACWlC,QAAAA,EACHA,cADGgC,EAAAY,cAEHA,YAAeZ,EAAGY,YA1ClC,MAAA,IAAAvB,OAAA,qCA3GPtB","file":"woleet-verify.min.js","sourcesContent":[";(function (root, factory) {\n    root.woleet = factory(root.woleet)\n})(window, function (woleet) {\n\n    const api = woleet || {};\n    api.receipt = api.receipt || {};\n    api.anchor = api.anchor || {};\n    api.verify = api.verify || {};\n\n    /**\n     * @param {File|String} file\n     * @param {Function} [progressCallback]\n     * @returns {Promise.<Object[]>}\n     */\n    api.verify.WoleetDAB = function (file, progressCallback) {\n\n        return api.hashFileOrCheckHash(file, progressCallback)\n\n        // We got the hash, now we get all corresponding public anchors ids\n            .then((hash) => api.anchor.getAnchorIDs(hash))\n\n            // We got public anchors ids (as an array)\n            .then((anchorIDsPage) => {\n\n                // For each public anchor, get the corresponding receipt\n                const receiptArray = [];\n                return anchorIDsPage.content.reduce((chain, anchorId) => {\n                    return chain.then(() => {\n                        return api.receipt.get(anchorId)\n                            .then((receipt) => receiptArray.push(receipt))\n                            .catch((error) => {\n                                // If we cannot get the corresponding receipt for\n                                // this anchorID because it's not yet processed (202)\n                                // we ignore this element, else we forward error\n                                if (error.code != 202) throw error;\n                            })\n                    })\n                }, Promise.resolve())\n\n                // Forward the receipt array\n                    .then(() => {\n                        // If we had a match but can't get a receipt\n                        if (!receiptArray.length && anchorIDsPage.content.length) {\n                            throw new Error('file_matched_but_anchor_not_yet_processed')\n                        }\n\n                        return receiptArray;\n                    });\n            })\n\n            // We got all public anchor receipts\n            .then((receiptArray) => {\n\n                // For each receipt we got\n                const receiptsCheckOk = receiptArray.map((receipt) => {\n                    try {\n                        // Validate the receipt\n                        api.receipt.validate(receipt);\n                        return true;\n                    } catch (err) {\n                        return false;\n                    }\n                });\n\n                // If all receipts are validated\n                const receiptsOk = receiptsCheckOk.every((e) => e == true);\n                if (receiptsOk) {\n\n                    // Build the result array\n                    const finalArray = [];\n                    return receiptArray.reduce((chain, receipt) => {\n                        return chain.then(() => {\n\n                            // Get the corresponding transaction\n                            return api.transaction.get(receipt.header.tx_id).then((tx) => {\n\n                                // Check that receipt's Merkle root matches transaction's OP_RETURN\n                                if (tx.opReturn == receipt.header.merkle_root) {\n                                    finalArray.push({\n                                        receipt: receipt,\n                                        confirmations: tx.confirmations,\n                                        confirmedOn: tx.confirmedOn\n                                    });\n                                }\n                                else\n                                    throw new Error('opReturn_mismatches_merkleRoot')\n                            })\n                        })\n                    }, Promise.resolve())\n\n                    // We got an array of object with {receipt, confirmations, confirmedOn}, so we forward it\n                        .then(() => finalArray)\n                }\n                else {\n                    throw new Error(\"invalid_receipt\");\n                }\n            })\n    };\n\n    /**\n     * @param {File|String} file\n     * @param {Receipt} receipt\n     * @param {Function} [progressCallback]\n     * @returns {Promise<Object>}\n     */\n    api.verify.DAB = function (file, receipt, progressCallback) {\n\n        return api.hashFileOrCheckHash(file, progressCallback)\n\n        // We got the hash\n            .then((hash) => {\n\n                // Validate the receipt\n                api.receipt.validate(receipt);\n\n                // Check that receipt's target hash matches the hash\n                if (receipt.target.target_hash != hash) throw new Error(\"target_hash_mismatch\");\n\n                // Get the transaction\n                return api.transaction.get(receipt.header.tx_id)\n                    .catch((error) => {\n                        if (error.message == 'tx_not_found') {\n                            throw error;\n                        }\n                        else {\n                            // We try a second time with a different provider\n                            api.transaction.setDefaultProvider('blockcypher.com');\n                            return api.transaction.get(receipt.header.tx_id);\n                        }\n                    })\n                    .catch((error) => {\n                        if (error.message == 'tx_not_found') {\n                            throw error;\n                        }\n                        else {\n                            throw new Error(\"error_while_getting_transaction\");\n                        }\n                    })\n            })\n\n            // We got the transaction\n            .then((tx) => {\n\n                // Check that receipt's Merkle root matches transaction's OP_RETURN\n                if (tx.opReturn == receipt.header.merkle_root)\n\n                // Return the result\n                    return {\n                        receipt: receipt,\n                        confirmations: tx.confirmations,\n                        confirmedOn: tx.confirmedOn\n                    };\n                else\n                    throw new Error('opReturn_mismatches_merkleRoot')\n            })\n    };\n\n    return api;\n});"]}