{"version":3,"sources":["woleet-verify.js"],"names":["root","factory","woleet","window","api","receipt","verify","WoleetDAB","file","progressCallback","hashFileOrCheckHash","then","hash","anchor","getAnchorIDs","anchorIDsPage","receiptArray","content","reduce","chain","anchorId","get","push","catch","error","code","Promise","resolve","length","Error","receiptsCheckOk","map","validate","err","receiptsOk","every","e","_ret","finalArray","v","transaction","header","tx_id","tx","opReturn","merkle_root","confirmedOn","_typeof","DAB","target","target_hash","message","setDefaultProvider","confirmations"],"mappings":"oOAAC,SAAWA,EAAMC,GACdD,EAAKE,OAASD,EAAQD,EAAKE,SAC5BC,OAAQ,SAAUD,GAFnB,GAAAE,GAAAF,KAoJsBG,OAnJpBL,GAAAA,QAAcC,EAAAA,YACfE,EAAAA,OAAQC,EAAUF,WAKjBE,EAAIE,OAASF,EAAIE,WAOjBF,EAAIE,OAAOC,UAAY,SAAUC,EAAMC,GAEnC,MAAOL,GAAIM,oBAAoBF,EAAMC,GAGhCE,KAAK,SAACC,GAAD,MAAUR,GAAIS,OAAOC,aAAaF,KAD5CD,KAAA,SAAAI,GAFO,GAAAC,KAUC,OAAOD,GAAcE,QAAQC,OAAO,SAACC,EAAOC,GALhD,MAAAD,GAAAR,KAAA,WACOI,MAAAA,GAAAA,QAAkBM,IAAAD,GAORT,KAAK,SAACN,GAAD,MAAaW,GAAaM,KAAKjB,KALjDkB,MAAA,SAAAC,GAImBnB,GAAYe,KAAZf,EAAJoB,KACFd,KAAKa,QAEFE,QAAAC,WAGAhB,KAAA,WAPZ,IAAAK,EAAAY,QAAAb,EAAAE,QAAAW,OAUOD,KAXJ,IAAAE,OAAA,4CAcG,OAAMb,OAWnBL,KAAK,SAACK,GAnCJ,GAAAc,GAAAd,EAAAe,IAAA,SAAA1B,GAuCK,IAGI,MAPLW,GAAAA,QAADgB,SAAkB3B,IAOL,EALf,MAAA4B,GACMH,OAAAA,KAKAI,EAAYJ,EAAAK,MAAA,SAAAC,GAAA,MAAA,IAAAA,GACV,KAAAF,EA0BK,KAAA,IAAAL,OAZD,kBAdJ,IAAAQ,GAAA,WASJ,GAAMC,KALV,QAAAC,EAAAvB,EAAAE,OAAA,SAAAC,EAAAd,GACM6B,MAAaJ,GAAAA,KAAAA,WACH,MAAA1B,GAAAoC,YAAAnB,IAAAhB,EAAAoC,OAAAC,OAAA/B,KAAA,SAAAgC,GAEZ,GAAAA,EAAAC,UAAAvC,EAAAoC,OAAAI,YAiBgB,KAAM,IAAIhB,OAAM,iCAhB1BS,GAANhB,MACAjB,QAAAA,EAAoBa,cAAOyB,EAACxB,cACjBA,YAAWwB,EAAAG,mBAONR,QAAAA,WAGIQ,KAAAA,WAAAA,MAAAA,QArBhB,IAAA,YAAA,mBAAAT,GAAA,YAAAU,QAAAV,IAAA,MAAAA,GAAAE,KAMQnC,EAAAE,OAAA0C,IAAA,SAAAxC,EAAAH,EAAAI,GA4BZ,MAAAL,GAAAM,oBAAgBF,EAAAC,GAhFhCE,KAAA,SAAAC,GAsGY,GAHAR,EAAIC,QAAQ2B,SAAS3B,GAGjBA,EAAQ4C,OAAOC,aAAetC,EAAM,KAAM,IAAIiB,OAAM,uBAGxD,OAAOzB,GAAIoC,YAAYnB,IAAIhB,EAAQoC,OAAOC,OAZvChC,MAAAA,SAAAA,GAcK,GAAqB,gBAAjBc,EAAM2B,QAZ1B,KAAA3B,EAkBoB,OAdAQ,GAAZQ,YAAAY,mBAAA,mBAcmBhD,EAAIoC,YAAYnB,IAAIhB,EAAQoC,OAAOC,SAGjDnB,MAAM,SAACC,GAZZ,KAAA,gBAAAA,EAAA2B,QACO3B,EAKM,GAAAK,OAAA,uCAOLlB,KAAA,SAAAgC,GAII,GAAAA,EAAAC,UAAMvC,EAAUoC,OAAAI,YA5B7B,OAyCSxC,QAASA,EARrBgD,cAAAV,EAAAU,cACOV,YAAOA,EAAAG,YAGHF,MAAAA,IAAHf,OAAexB,qCAIXA","file":"woleet-verify.min.js","sourcesContent":[";(function (root, factory) {\n    root.woleet = factory(root.woleet)\n})(window, function (woleet) {\n\n    const api = woleet || {};\n    api.receipt = api.receipt || {};\n    api.anchor = api.anchor || {};\n    api.verify = api.verify || {};\n\n    /**\n     * @param {File|String} file\n     * @param {Function} [progressCallback]\n     * @returns {Promise.<Object[]>}\n     */\n    api.verify.WoleetDAB = function (file, progressCallback) {\n\n        return api.hashFileOrCheckHash(file, progressCallback)\n\n        // We got the hash, now we get all corresponding public anchors ids\n            .then((hash) => api.anchor.getAnchorIDs(hash))\n\n            // We got public anchors ids (as an array)\n            .then((anchorIDsPage) => {\n\n                // For each public anchor, get the corresponding receipt\n                const receiptArray = [];\n                return anchorIDsPage.content.reduce((chain, anchorId) => {\n                    return chain.then(() => {\n                        return api.receipt.get(anchorId)\n                            .then((receipt) => receiptArray.push(receipt))\n                            .catch((error) => {\n                                // If we cannot get the corresponding receipt for\n                                // this anchorID because it's not yet processed (202)\n                                // we ignore this element, else we forward error\n                                if (error.code != 202) throw error;\n                            })\n                    })\n                }, Promise.resolve())\n\n                // Forward the receipt array\n                    .then(() => {\n                        // If we had a match but can't get a receipt\n                        if (!receiptArray.length && anchorIDsPage.content.length) {\n                            throw new Error('file_matched_but_anchor_not_yet_processed')\n                        }\n\n                        return receiptArray;\n                    });\n            })\n\n            // We got all public anchor receipts\n            .then((receiptArray) => {\n\n                // For each receipt we got\n                const receiptsCheckOk = receiptArray.map((receipt) => {\n                    try {\n                        // Validate the receipt\n                        api.receipt.validate(receipt);\n                        return true;\n                    } catch (err) {\n                        return false;\n                    }\n                });\n\n                // If all receipts are validated\n                const receiptsOk = receiptsCheckOk.every((e) => e == true);\n                if (receiptsOk) {\n\n                    // Build the result array\n                    const finalArray = [];\n                    return receiptArray.reduce((chain, receipt) => {\n                        return chain.then(() => {\n\n                            // Get the corresponding transaction\n                            return api.transaction.get(receipt.header.tx_id).then((tx) => {\n\n                                // Check that receipt's Merkle root matches transaction's OP_RETURN\n                                if (tx.opReturn == receipt.header.merkle_root) {\n                                    finalArray.push({\n                                        receipt: receipt,\n                                        confirmations: tx.confirmations,\n                                        confirmedOn: tx.confirmedOn\n                                    });\n                                }\n                                else\n                                    throw new Error('opReturn_mismatches_merkleRoot')\n                            })\n                        })\n                    }, Promise.resolve())\n\n                    // We got an array of object with {receipt, confirmations, confirmedOn}, so we forward it\n                        .then(() => finalArray)\n                }\n                else {\n                    throw new Error(\"invalid_receipt\");\n                }\n            })\n    };\n\n    /**\n     * @param {File|String} file\n     * @param {Receipt} receipt\n     * @param {Function} [progressCallback]\n     * @returns {Promise<Object>}\n     */\n    api.verify.DAB = function (file, receipt, progressCallback) {\n\n        return api.hashFileOrCheckHash(file, progressCallback)\n\n        // We got the hash\n            .then((hash) => {\n\n                // Validate the receipt\n                api.receipt.validate(receipt);\n\n                // Check that receipt's target hash matches the hash\n                if (receipt.target.target_hash != hash) throw new Error(\"target_hash_mismatch\");\n\n                // Get the transaction\n                return api.transaction.get(receipt.header.tx_id)\n                    .catch((error) => {\n                        if (error.message == 'tx_not_found') {\n                            throw error;\n                        }\n                        else {\n                            // We try a second time with a different provider\n                            api.transaction.setDefaultProvider('blockcypher.com');\n                            return api.transaction.get(receipt.header.tx_id);\n                        }\n                    })\n                    .catch((error) => {\n                        if (error.message == 'tx_not_found') {\n                            throw error;\n                        }\n                        else {\n                            throw new Error(\"error_while_getting_transaction\");\n                        }\n                    })\n            })\n\n            // We got the transaction\n            .then((tx) => {\n\n                // Check that receipt's Merkle root matches transaction's OP_RETURN\n                if (tx.opReturn == receipt.header.merkle_root)\n\n                // Return the result\n                    return {\n                        receipt: receipt,\n                        confirmations: tx.confirmations,\n                        confirmedOn: tx.confirmedOn\n                    };\n                else\n                    throw new Error('opReturn_mismatches_merkleRoot')\n            })\n    };\n\n    return api;\n});"]}