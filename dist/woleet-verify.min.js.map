{"version":3,"sources":["woleet-verify.js"],"names":["root","factory","woleet","window","api","receipt","verify","WoleetDAB","file","then","hash","anchor","getAnchorIDs","anchorIDsPage","receiptArray","content","reduce","chain","anchorId","push","error","code","Promise","resolve","length","Error","receiptsCheckOk","map","validate","err","receiptsOk","every","e","finalArray","transaction","get","header","tx_id","tx","confirmations","date","confirmedAt","hashStringOrFile","target","target_hash","message","opReturn","merkle_root","hashPromise","resolveHash","rejectHash","hasher","reject","Hasher","on","result"],"mappings":"cAAC,SAAWA,EAAMC,GACdD,EAAKE,OAASD,EAAQD,EAAKE,SAD7BC,OAAA,SAAgBF,GAEfE,GAAAA,GAAQD,KAGPE,GAAIC,QAAUD,EAAIC,YADlBD,EAAIA,OAAMF,EAAAA,WACVE,EAAIC,OAAJD,EAAcA,WAQdA,EAAIE,OAAOC,UAAY,SAAUC,GAA7BF,MAAOC,GAAYC,GAKdC,KAAK,SAAUC,GADpB,MAAAN,GAAAO,OAAAC,aAAAF,KAFOD,KAAA,SAAAI,GAMH,GAAAC,KACM,OAAAD,GAAAE,QAAyBC,OAAA,SAAAC,EAAAC,GACvBJ,MAAAA,GAAJL,KAAA,WACOI,MAAAA,GAAcE,QAAQC,IAAtBE,GAA6BT,KAAUQ,SAAOC,GAC1CD,MAAWH,GAAYK,KAAAd,IACnBD,SAAIC,GAIP,GAAA,KAAAe,EAAAC,KAAA,KAAAD,QAGHE,QAPDC,WAYHd,KAAK,WAAA,IAAAK,EAAYU,QAAAX,EAAAE,QAAAS,OACd,KAAA,IAAAC,OAAA,4CAGC,OAAAX,OAOZL,KAAK,SAAUK,GAIR,GAAIY,GAAAZ,EAAAa,IAAA,SAAAtB,GACA,IACF,MAAYD,GAAAC,QAAAuB,SAAAvB,GACV,MAAOwB,GACV,OAAA,KAKDC,EAAAJ,EAAAK,MAAA,SAAAC,GADJ,MAAA,IAAAA,IAIIC,IAIA,IAAAH,EACI,MAAOb,GAAWD,OAAA,SAAYC,EAAAZ,GAC1B,MAAOD,GAAI8B,KAAAA,WACPD,MAAAA,GAAWd,YAAKgB,IAAA9B,EAAA+B,OAAAC,OAAA5B,KAAA,SAAA6B,GACZjC,EAASA,MACTkC,QAAAA,EACAC,cAASC,EAAAA,cAHbD,KAAAF,EAAAG,mBAOTnB,QAAQC,WAIHd,KAAOwB,WAdf,MAAAA,IAtDZ,MAAA,IAAAR,OAAA,sBAoFArB,EAAAE,OAAOoC,IAAAA,SAAAA,EAAArC,GAICD,MAAAA,GAAAI,GAEAC,KAAIJ,SAAQsC,GAKL,GAHPvC,EAAOA,QAAI8B,SAAYC,GAGhB9B,EAAUe,OAAOwB,aAAAlC,EAAA,KAAA,IAAAe,OAAA,uBAEZ,OAAArB,GAAMgB,YAANe,IAAA9B,EAAA+B,OAAAC,OADJ5B,KAGK,SAAA6B,GACD,MAAUb,IACb,SAAAL,GATT,KAAA,gBAAAA,EAAAyB,QAagBzB,EAGL,GAAAK,OAAA,uCAxBnBhB,KAAA,SAAA6B,GAuBQ,GAAIA,EAAGQ,UAAYzC,EAAQ+B,OAAOW,YAY1CL,OACArC,QAAAA,EACAkC,cAAAD,EAAAC,cACIS,KAAkB1B,EAAAA,YAAtB,MAAA,IAAAG,OAAA,oCAHJ,IAAIiB,GAAmB,SAAUlC,GAYzB,GAAAyC,GACAC,EACAC,EAAU,GAAV7B,SAAoB,SAAUuB,EAAeO,GACzCH,EAAAA,EACHC,EAFDE,GAKIF,IAAAA,YAAW9B,MAAX,CATJ,IAAKhB,EAAII,OAASJ,EAAII,KAAK6C,OAAQ,KAAM,IAAI5B,OAAM,iCAFvD,IAgBK0B,GAAI,GAAO3C,GAAPA,KAAe6C,MAEhBF,GAAAG,GAAA,SAAA,SAAAT,EAAArC,GACAyC,EAAYzC,EAAZ+C,UAIAL,EAAAA,GAAAA,QAAezB,SAAML,GACxB8B,EAAA9B,KAID8B,EAAAA,MAAW1C,OAZS,gBAARA,GAeTwC,EAAAA,SAAPxC,GAZQyC,EAAYzC,GAIZ0C,EAAW,GAAIzB,OAAM,uCAKzByB,EAAW,GAAIzB,OAAM,qBAGzB,OAAOuB,GAGX,OAAO5C","file":"woleet-verify.min.js","sourcesContent":[";(function (root, factory) {\n    root.woleet = factory(root.woleet)\n})(window, function (woleet) {\n\n    var api = woleet || {};\n    api.receipt = api.receipt || {};\n    api.anchor = api.anchor || {};\n    api.verify = api.verify || {};\n\n    /**\n     * @param {File|String} file\n     * @returns {Promise.<Object[]>}\n     */\n    api.verify.WoleetDAB = function (file) {\n\n        return hashStringOrFile(file)\n\n        // we get the hash, so now we get the corresponding anchor ids\n            .then(function (hash) {\n                return api.anchor.getAnchorIDs(hash);\n            })\n            // we got ids (an array), for each of them, we get the corresponding receipts\n            .then(function (anchorIDsPage) {\n                var receiptArray = [];\n                return anchorIDsPage.content.reduce(function (chain, anchorId) {\n                    return chain.then(function () {\n                        return api.receipt.get(anchorId).then(function (receipt) {\n                            return receiptArray.push(receipt)\n                        }, function (error) {\n                            // if we cannot get the corresponding receipt for\n                            // this anchorID because it's not yet processed (202)\n                            // we ignore this element, else we forward error\n                            if (error.code != 202) throw error;\n                        })\n                    })\n                }, Promise.resolve())\n\n                // we got a receipt array, so we forward it\n                    .then(function () {\n                        // if we had a match but can't get a receipt\n                        if (!receiptArray.length && anchorIDsPage.content.length) {\n                            throw new Error('file_matched_but_anchor_not_yet_processed')\n                        }\n\n                        return receiptArray;\n                    });\n\n            })\n\n            .then(function (receiptArray) {\n\n                // we check each receipt we got\n                var receiptsCheckOk = receiptArray.map(function (receipt) {\n                    try {\n                        return api.receipt.validate(receipt);\n                    } catch (err) {\n                        return false;\n                    }\n                });\n\n                // we check that all of them are correct\n                var receiptsOk = receiptsCheckOk.every(function (e) {\n                    return e == true\n                });\n\n                var finalArray = [];\n\n                // if so, we get the corresponding transaction\n                if (receiptsOk) {\n                    return receiptArray.reduce(function (chain, receipt) {\n                        return chain.then(function () {\n                            return api.transaction.get(receipt.header.tx_id).then(function (tx) {\n                                finalArray.push({\n                                    receipt: receipt,\n                                    confirmations: tx.confirmations,\n                                    date: tx.confirmedAt\n                                })\n                            })\n                        })\n                    }, Promise.resolve())\n\n                    // we got a array of object with the {receipt, transactionDate}, so we forward it\n                        .then(function () {\n                            return finalArray;\n                        })\n                }\n                else {\n                    throw new Error(\"invalid_receipt\");\n                }\n            })\n    };\n\n    /**\n     * @param {File|String} file\n     * @param {Receipt} receipt\n     * @returns {Promise<Object>}\n     */\n    api.verify.DAB = function (file, receipt) {\n\n        return hashStringOrFile(file)\n\n            .then(function (hash) {\n\n                api.receipt.validate(receipt);\n\n                if (receipt.target.target_hash != hash) throw new Error(\"target_hash_mismatch\");\n\n                return api.transaction.get(receipt.header.tx_id)\n                    .then(function (tx) {\n                        return tx;\n                    }, function (error) {\n                        if (error.message == 'tx_not_found') {\n                            throw error;\n                        }\n                        else {\n                            throw new Error(\"error_while_getting_transaction\")\n                        }\n                    })\n            })\n\n            .then(function (tx) {\n\n                if (tx.opReturn == receipt.header.merkle_root)\n                    return {\n                        receipt: receipt,\n                        confirmations: tx.confirmations,\n                        date: tx.confirmedAt\n                    }; // opReturn matches root\n                else\n                    throw new Error('opReturn_mismatches_merkleRoot')\n\n            })\n    };\n\n    var hashStringOrFile = function (file) {\n        var resolveHash;\n        var rejectHash;\n        var hashPromise = new Promise(function (resolve, reject) {\n            resolveHash = resolve;\n            rejectHash = reject;\n        });\n\n        if (file instanceof File) {\n\n            if (!api.file || !api.file.Hasher) throw new Error(\"missing_woleet_hash_dependency\");\n\n            var hasher = new api.file.Hasher;\n            //noinspection JSUnusedLocalSymbols\n            hasher.on('result', function (message, file) {\n                resolveHash(message.result);\n            });\n\n            hasher.on('error', function (error) {\n                rejectHash(error);\n            });\n\n            hasher.start(file)\n        }\n        else if (typeof file == \"string\") {\n            if (api.isSHA256(file)) {\n                //noinspection JSUnusedAssignment\n                resolveHash(file);\n            }\n            else {\n                //noinspection JSUnusedAssignment\n                rejectHash(new Error(\"parameter_string_not_a_sha256_hash\"));\n            }\n        }\n        else {\n            //noinspection JSUnusedAssignment\n            rejectHash(new Error(\"invalid_parameter\"));\n        }\n\n        return hashPromise;\n    };\n\n    return api;\n});"]}