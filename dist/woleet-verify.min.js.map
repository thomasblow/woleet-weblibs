{"version":3,"sources":["woleet-verify.js"],"names":["root","factory","woleet","window","api","receipt","verify","WoleetDAB","file","progressCallback","then","hash","anchor","getAnchorIDs","anchorIDsPage","receiptArray","content","reduce","chain","anchorId","push","error","code","Promise","resolve","length","Error","receiptsCheckOk","map","validate","err","receiptsOk","every","e","finalArray","transaction","get","header","tx_id","tx","confirmations","date","confirmedOn","hashStringOrFile","target","target_hash","message","opReturn","merkle_root","resolveHash","rejectHash","hashPromise","Hasher","reject","hasher","File","on","result","progress","isSHA256","start"],"mappings":"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","file":"woleet-verify.min.js","sourcesContent":[";(function (root, factory) {\n    root.woleet = factory(root.woleet)\n})(window, function (woleet) {\n\n    var api = woleet || {};\n    api.receipt = api.receipt || {};\n    api.anchor = api.anchor || {};\n    api.verify = api.verify || {};\n\n    /**\n     * @param {File|String} file\n     * @param {Function} [progressCallback]\n     * @returns {Promise.<Object[]>}\n     */\n    api.verify.WoleetDAB = function (file, progressCallback) {\n\n        return hashStringOrFile(file, progressCallback)\n\n        // We get the hash, so now we get the corresponding anchor ids\n            .then(function (hash) {\n                return api.anchor.getAnchorIDs(hash);\n            })\n\n            // We got ids (an array), for each of them, we get the corresponding receipts\n            .then(function (anchorIDsPage) {\n                var receiptArray = [];\n                return anchorIDsPage.content.reduce(function (chain, anchorId) {\n                    return chain.then(function () {\n                        return api.receipt.get(anchorId).then(function (receipt) {\n                            return receiptArray.push(receipt)\n                        }, function (error) {\n                            // if we cannot get the corresponding receipt for\n                            // this anchorID because it's not yet processed (202)\n                            // we ignore this element, else we forward error\n                            if (error.code != 202) throw error;\n                        })\n                    })\n                }, Promise.resolve())\n\n                // We got a receipt array, so we forward it\n                    .then(function () {\n                        // if we had a match but can't get a receipt\n                        if (!receiptArray.length && anchorIDsPage.content.length) {\n                            throw new Error('file_matched_but_anchor_not_yet_processed')\n                        }\n\n                        return receiptArray;\n                    });\n\n            })\n\n            .then(function (receiptArray) {\n\n                // We check each receipt we got\n                var receiptsCheckOk = receiptArray.map(function (receipt) {\n                    try {\n                        return api.receipt.validate(receipt);\n                    } catch (err) {\n                        return false;\n                    }\n                });\n\n                // We check that all of them are correct\n                var receiptsOk = receiptsCheckOk.every(function (e) {\n                    return e == true\n                });\n\n                var finalArray = [];\n\n                // If so, we get the corresponding transaction\n                if (receiptsOk) {\n                    return receiptArray.reduce(function (chain, receipt) {\n                        return chain.then(function () {\n                            return api.transaction.get(receipt.header.tx_id).then(function (tx) {\n                                finalArray.push({\n                                    receipt: receipt,\n                                    confirmations: tx.confirmations,\n                                    date: tx.confirmedOn\n                                })\n                            })\n                        })\n                    }, Promise.resolve())\n\n                    // We got a array of object with the {receipt, transactionDate}, so we forward it\n                        .then(function () {\n                            return finalArray;\n                        })\n                }\n                else {\n                    throw new Error(\"invalid_receipt\");\n                }\n            })\n    };\n\n    /**\n     * @param {File|String} file\n     * @param {Receipt} receipt\n     * @param {Function} [progressCallback]\n     * @returns {Promise<Object>}\n     */\n    api.verify.DAB = function (file, receipt, progressCallback) {\n\n        return hashStringOrFile(file, progressCallback).then(function (hash) {\n\n            api.receipt.validate(receipt);\n\n            if (receipt.target.target_hash != hash) throw new Error(\"target_hash_mismatch\");\n\n            return api.transaction.get(receipt.header.tx_id)\n                .then(function (tx) {\n                    return tx;\n                }, function (error) {\n                    if (error.message == 'tx_not_found') {\n                        throw error;\n                    }\n                    else {\n                        throw new Error(\"error_while_getting_transaction\")\n                    }\n                })\n        })\n\n            .then(function (tx) {\n\n                if (tx.opReturn == receipt.header.merkle_root)\n                    return {\n                        receipt: receipt,\n                        confirmations: tx.confirmations,\n                        confirmedOn: tx.confirmedOn\n                    }; // opReturn matches root\n                else\n                    throw new Error('opReturn_mismatches_merkleRoot')\n\n            })\n    };\n\n    /**\n     * @param {File|String} file\n     * @param {Function} [progressCallback]\n     * @returns {Promise<Hash>}\n     */\n    var hashStringOrFile = function hashStringOrFile(file, progressCallback) {\n        var resolveHash;\n        var rejectHash;\n        var hashPromise = new Promise(function (resolve, reject) {\n            resolveHash = resolve;\n            rejectHash = reject;\n        });\n\n        if (file instanceof File) {\n\n            if (!api.file || !api.file.Hasher) throw new Error(\"missing_woleet_hash_dependency\");\n\n            var hasher = new api.file.Hasher;\n            //noinspection JSUnusedLocalSymbols\n            hasher.on('result', function (message, file) {\n                resolveHash(message.result);\n                if (progressCallback) progressCallback({progress: 1.0, file: File})\n            });\n\n            if (progressCallback && typeof progressCallback == 'function') {\n                hasher.on('progress', progressCallback);\n            }\n\n            hasher.on('error', function (error) {\n                rejectHash(error);\n            });\n\n            hasher.start(file)\n        }\n        else if (typeof file == \"string\") {\n            if (api.isSHA256(file)) {\n                //noinspection JSUnusedAssignment\n                resolveHash(file);\n            }\n            else {\n                //noinspection JSUnusedAssignment\n                rejectHash(new Error(\"parameter_string_not_a_sha256_hash\"));\n            }\n        }\n        else {\n            //noinspection JSUnusedAssignment\n            rejectHash(new Error(\"invalid_parameter\"));\n        }\n\n        return hashPromise;\n    };\n\n    return api;\n});"]}